#!/usr/bin/python3

import sys
import os
import importlib
import signal
from threading import Thread
import gi
from gi.repository import GLib
import gettext
import getpass
import collections.abc
import copy
import json
from functools import partial
import time

import requests #Grabbing files from internet

class StoreBrainException(Exception): # Name this according to the module to allow easier debugging
    pass

#TODO: Brain API instead of storebrain access for everything, and simplify the GUI and Brain code
#TODO: Move package information stuff to package manager plugins, and merge generic into the other plugins
#TODO: Make Store Brain trigger refresh_memory on modules when loaded, and allow refreshing of modules pool
#TODO: For subsources and sources, default the values to the one belonging to the first installed case, if possible (but for sources only in the event of entering the page)
# ICE: dewit
# APT: dewit (maybe later?)
# Snap: dewit
# Flatpak: dewit
# Brain: dewit
# GUI: dewit

#Merge notes
# Removed lastpkgviewed, pkgmgmtbusy, locale (move to Store API), pkg_categoryids, get_generic_information, get_information, get_subsources (now part of getSources)
# pkg_ids is now dict (stores category in each one)
# curated data.json value obtaining is now in API
# task_* now returns Success?, and Output (for failure)

#The API modules use to interface with the Brain (this code)
#Generic (for all modules)
class StoreGenericAPI():
    def __init__(self):
        #self.getDefaultItemInformation = Store.getDefaultItemInformation
        #self.getSpecificItemInformation = Store.getSpecificItemInformation
        #self.getAvailableSources = Store.getAvailableSources
        #self.canceltask = Tasks.cancelTask
        #self.installApp = Store.installApp
        #self.updateApp = Store.updateApp
        #self.removeApp = Store.removeApp
        #self.addSource = Store.addSource
        #self.removeSource = Store.removeSource
        #self.showTaskConfirmation = Store.showTaskConfirmation
        #self.gotoID = Store.gotoID
        #self.refreshMemory = Store.refreshMemory
        #self.reloadStore = Store.reloadStore
        #self.reloadPages = Store.reloadPages
        #self.reloadPkgStates = Store.reloadPkgStates
        #self.fullUpdate = Store.fullUpdate
        #self.itemSearch = Store.itemSearch
        #self.getAutoUpdateOn = Store.getAutoUpdateOn
        #self.getAutoUpdateBandwidthOn = Store.getAutoUpdateBandwidthOn
        pass


#Tasks (for ONLY Tasks module)
class StoreTasksAPI():
    def __init__(self):
        #self.addConfirmedTask = Store.addConfirmedTask
        #self.deleteTask = Store.deleteTask
        #self.runTask = Store.runTask
        #self.showFailure = Store.showFailure
        #self.cleanupModule = Store.cleanupModule
        pass


#Settings (for ONLY Settings modules)
class StoreSettingsAPI():
    def __init__(self):
        #self.changeAutoUpdateOn = Store.changeAutoUpdateOn
        #self.getAutoUpdateSupported = Store.getAutoUpdateSupported
        #self.changeAutoUpdateBandwidthOn = Store.changeAutoUpdateBandwidthOn
        #self.getAutoUpdateBandwidthSupported = Store.getAutoUpdateBandwidthSupported
        #self.getPackageMgmtModulesInfo = Store.getPackageMgmtModulesInfo
        pass



#This class here is the main brains that connect the pieces of code together per each module
class StoreModuleContainer():
    def __init__(self, path):
        pass
    
    
        
    
    
    
#Tasks body for Tasks storage
class TaskBody():
    def __init__(self, itemid, moduleid, operation, sourceid, subsourceid, becauseof="", dependson="", directto=""):
        self.itemid = itemid #ID of item, e.g.: mozilla-firefox
        self.moduleid = moduleid #ID of module, e.g.: packagemgmt-apt
        self.operation = operation #0 for install/add, 1 for remove, 2 for update
        self.sourceid = sourceid #ID of source to obtain from
        self.subsourceid = subsourceid #ID of subsource to obtain from, if appropriate
        self.becauseof = becauseof #(optional) Task was because of - status matches said task's, and completes with that task
        self.dependson = dependson #(optional) Task depends on said task - if said task cancels or fails, this does too
        self.directto = directto #Item ID to direct users to the page for upon clicking
        
        self.cancellable = True #Can be cancelled?
        self.pendingconfirm = True #Task won't run until confirmation is made
        self.cancelling = False #Task is in process of being cancelled?
        self.bonusids = [] #These get appended to by confirmation dialog
        
        self.progress = 0 #Progress percent
        self.status = 0 #Status type (0 = Unconfirmed, 1 = Pending, 2 = Staged (post-logout), 3 = Staging (to be done next Store instance), 4 = In Progress)
        
        
class TaskManager():    
    def __init__(self):
        self.tasks = {"visibleorder": {}} #List of Tasks, in chronological order and modules order
        #self.storeAPI = StoreGenericAPI NOTE: StoreBrain gives it this
        #self.storeTasksAPI = StoreTasksAPI NOTE: StoreBrain gives it this
        
        self.stage_tasks = False #Are we logging out, or is Store about to restart (if so, stage future tasks instead)
        
        #For Tasks Management
        self.doing_tasks = {} #Is tasks management running? (per module)
        self.confirming_tasks = False #Is tasks management - pending tasks running?
    
    
    def add_task(self, itemid, moduleid, operation, sourceid, subsourceid, becauseof="", dependson="", directto="", preconfirmed=False):
        #Create a Task Body for our new task
        newtask = TaskBody(itemid, moduleid, operation, sourceid, subsourceid, becauseof, follows, directto)
        if self.stage_tasks == True:
            newtask.status = 3 #Set status to Staging
        elif preconfirmed == True:
            newtask.status = 1 #Set status to Pending
        
        #Add to tasks order, and then to order list
        if not moduleid in self.tasks:
            self.tasks[moduleid] = []
        self.tasks["order"][moduleid+":"+itemid+":"+sourceid+":"+subsourceid+":"+str(operation)] = newtask
        self.tasks[moduleid].append(moduleid+":"+itemid+":"+sourceid+":"+subsourceid+":"+str(operation))
        
        #Refresh item state in GUI to make it now be known to be in-tasks
        self.storeAPI.reloadPkgStates([moduleid], [itemid])
        
        #Trigger tasks launching in case it isn't doing tasks
        self.begin_tasks_management()
    
        
    def cancel_task(self, taskid): #Cancel task
        if taskid not in self.tasks["order"]:
            raise StoreBrainException("The task %s could not be cancelled as it does not exist as a task. Perhaps the task finished?" % taskid)
        if self.tasks["order"][taskid].cancellable == False:
            raise StoreBrainException("The task %s could not be cancelled." % taskid)
        self.storeAPI.cancelTask(taskid)
        
        
    def begin_tasks_management(self):
        #Launch pending tasks confirmations task if not running already
        self.begin_unconfirmed_tasks()
        #Launch main tasks runner
        self.begin_tasks()
            
        
    def begin_unconfirmed_tasks(self):        
        thread = Thread(target=self._begin_unconfirmed_tasks,
                        args=())
        thread.daemon = True
        thread.start()
        
    def _begin_unconfirmed_tasks(self):
        if self.confirming_tasks == True:
            return #It's already running, don't bother running it again
        
        self.confirming_tasks = True
        tasksdonethisloop = 1
        
        while tasksdonethisloop != 0:
            tasksdonethisloop = 0
            for item in self.tasks["order"]:
                if self.tasks["order"][item].status == 0:
                    tasksdonethisloop += 1
                    
                    #TODO: Make call to module to get package changes made
                    itemsadded, itemsupdated, itemsremoved, bonusoptions = {"mozilla-firefox"}, {}, {}, {"ice-extra-darkreader-chromium"} #FIXME: Test values
                    
                    response, bonusids = self.storeAPI.showTaskConfirmation(self.tasks["order"][item], itemsadded, itemsupdated, itemsremoved, bonusoptions)
                    
                    if response == False:
                        self.storeAPI.cancelTask(item) #Cancel if No
                        continue #Skip to next loop item
                    
                    self.tasks["order"][item].bonusids = bonusids #Set tasks's bonuses
                    self.tasks["order"][item].status = 1 #Set status to Pending (confirmed) as well
                    
                    #Refresh item state in GUI to address the state change
                    self.storeAPI.reloadPkgStates([self.tasks["order"][item].moduleid], [self.tasks["order"][item].itemid])
            
            
        self.confirming_tasks = False
        print("TASKS DEBUG ("+module+"): unconfirmed tasks is all done, returning.")
            
        
    def begin_tasks(self):        
        for moduleid in self.tasks: #Initiate tasks working for all modules
            if moduleid != "order": #Skip the 'order' variable
                thread = Thread(target=self._begin_tasks,
                                args=(moduleid,))
                thread.daemon = True
                thread.start()
        
    def _begin_tasks(self, moduleid):
        if not moduleid in self.doing_tasks:
            return #No tasks to do
        if self.doing_tasks[moduleid] == True:
            return #It's already running, don't bother running it again
        
        self.doing_tasks[moduleid] = True
        tasksdonethisloop = 1
        
        while tasksdonethisloop != 0:
            tasksdonethisloop = 0
            for item in self.tasks["order"]:
                if self.tasks["order"][item].status == 1 and self.tasks["order"][item].moduleid == moduleid:
                    tasksdonethisloop += 1
                    
                    self.do_task(item)
                    
                    #Delete task now it's finished
                    self.storeTasksAPI.deleteTask(item)
                    
                    #Refresh item state in GUI to address the task completion
                    self.storeAPI.reloadPkgStates([self.tasks["order"][item].moduleid], [self.tasks["order"][item].itemid])
            
            
        self.tasksrunning[module] = False
        print("TASKS DEBUG ("+module+"): currenttasks is all done, returning.")
        
        
    def do_task(self, taskid):
        currenttask = self.tasks["order"][taskid]
        
        currenttask.status = 4 #Set status to In Progress
        
        #Refresh item state in GUI to address the task completion
        self.storeAPI.reloadPkgStates([currenttask.moduleid], [currenttask.itemid])
        
        print("TASKS DEBUG: Working on", taskname)
        try:
            self.storeTasksAPI.runTask(currenttask)
        except Exception as exceptionstr:
            self.storeTasksAPI.showFailure(currenttask, exceptionstr)
        
        thread.daemon = True
        thread.start()
        
        self.storeTasksAPI.cleanup_module(currenttask.moduleid)


class StoreBrain():
    # Modules Management
    ##############################################
    def new_module(self, modulepath):
        #First off, check module is even valid in the first place
        if not os.path.isfile(modulepath + "/storemodule.py"):
            raise StoreBrainException("Invalid module")
        with open(modulepath + "/storemodule.py", 'r') as modulecheck:
            check = False
            for i in modulecheck:
                if "class module(" in i:
                    check = True
            if check == False:
                raise StoreBrainException("Invalid module")
        
        #Create new module and return it
        result = StoreModuleContainer(modulepath)
        
        sys.path.insert(1, modulepath)
        exceptionstr = ""
        try:
            import storemodule
            importlib.reload(storemodule) #Otherwise only one module will be loaded across all variables
            
            result = storemodule.module(self.genericapi)

            #Now give the module an ID so Store can store it later
            result.moduleid = modulepath.split("/")[-2] + "-" + modulepath.split("/")[-1]
        except Exception as e:
            exceptionstr = e

        #Now remove it from path, irregardless
        sys.path.remove(modulepath)

        if exceptionstr != "":
            raise StoreBrainException(exceptionstr)
        else:
            result.refresh_memory()
            return result
        
    #Load the initial modules
    def load_modules(self):
        MODULES_DIR = "/usr/lib/feren-storium/modules"
        
        #TODO: Make these lists be managed by gsettings or similar
        if os.path.exists(MODULES_DIR):
            for dir_name in sorted(os.listdir(MODULES_DIR+"/localpackagemgmt")):
                path = os.path.join(MODULES_DIR+"/localpackagemgmt", dir_name)
                module = None
                try:
                    module = self.new_module(path)
                    self.modules[module.moduleid] = module
                    #TODO: self.modules["localpackagemgmt-"+dir_name].storemanagementapi = self.managementapi
                except Exception as e:
                    print("Failed to load local package management module %s: \n%s\n" % (dir_name, e))

            for dir_name in sorted(os.listdir(MODULES_DIR+"/packagemgmt")):
                path = os.path.join(MODULES_DIR+"/packagemgmt", dir_name)
                module = None
                try:
                    module = self.new_module(path)
                    self.modules[module.moduleid] = module
                    #TODO: self.modules["packagemgmt-"+dir_name].storemanagementapi = self.managementapi
                except Exception as e:
                    print("Failed to load package management module %s: \n%s\n" % (dir_name, e))

            for dir_name in sorted(os.listdir(MODULES_DIR+"/search")):
                path = os.path.join(MODULES_DIR+"/search", dir_name)
                module = None
                try:
                    module = self.new_module(path)
                    self.modules[module.moduleid] = module
                    #No extra APIs for search.
                except Exception as e:
                    print("Failed to load search module %s: \n%s\n" % (dir_name, e))

            #TODO: Move source information module to package management modules

            for dir_name in sorted(os.listdir(MODULES_DIR+"/settings")):
                path = os.path.join(MODULES_DIR+"/settings", dir_name)
                module = None
                try:
                    module = self.new_module(path)
                    self.modules[module.moduleid] = module
                    #TODO: self.modules["settings-"+dir_name].storemanagementapi = self.managementapi
                except Exception as e:
                    print("Failed to load settings module %s: \n%s\n" % (dir_name, e))
                    
                    
    # API functions passed from Store into StoreAPI
    ##############################################
    def APIgetDefaultItemInformation(self, itemid):
        #Get full information about an item from the most recommended source it is available in
        pass #TODO: Move current code into here
        #Also TODO: Check item availability first, then go by source order of what is available to find the information

    def APIgetSpecificItemInformation(self, itemid, moduleid, sourceid, subsourceid):
        #Get information about an item from the specified source
        result = self.modules[moduleid].getInfo(itemid, sourceid, subsourceid)
        return result

    def APIgetAvailableSources(self, itemid):
        #Get the sources for this package id {sourcename: subsources]}, split into "recommended", "normal", and "nonrecommended"
        #TODO: Split into 3 types, listed on above line
        result = {"recommended": {}, "normal": {}, "nonrecommended": {}}

        for module in self.modules:
            if module.startswith("packagemgmt-"):
                try:
                    sources = self.modules[module].getSources(itemid)
                    for source in sources:
                        if self.modules[module].getAvailable(itemid, source) != 1:
                            #Add to available sources return if available
                            result["normal"][module+":"+source] = sources[source]
                            result["normal"][module+":"+source]["id"] = module+":"+source
                except:
                    pass


        #TODO: Iterate over them to check that no names match, and if so append their sourcesmodulename to them in brackets

        return result

    def APIgetCuratedJSON(self, jsonpath):
        #Returns dict consisting of data from a JSON file in the curated folder
        with open("/usr/share/feren-storium/curated/" + jsonpath + "/data.json", 'r') as fp:
            return json.loads(fp.read())


    def APIcancelTask(self, taskid):
        #Cancels the task of that Task ID
        # If it isn't found or cannot be cancelled, throw an exception.
        if taskid not in self.taskManager.tasks:
            raise StoreBrainException(_("%s does not exist as a task. Perhaps the task finished?") % taskid)
        if self.taskManager.tasks[taskid].cancellable == False:
            raise StoreBrainException(_("The task %s cannot be cancelled.") % taskid)
        #Get the module to cancel the task, otherwise
        try:
            self.modules[self.taskManager.tasks[taskid].moduleid].taskCancel(taskid)
        except Exception as e:
            raise StoreBrainException(_("The task {0} could not be cancelled as the following error occurred while cancelling it: {1}").format(taskid, e))
        #Now delete the task since it was cancelled
        self.storeTasksAPI.deleteTask(taskid)


    def APIinstallApp(self, itemid, moduleid, sourceid, subsourceid):
        #Installs the item of itemid from sourceid : subsourceid, using moduleid
        self.taskManager.add_task(itemid, moduleid, 0, sourceid, subsourceid, "", "", itemid, False)

    def APIupdateApp(self, itemid, moduleid, sourceid, subsourceid):
        #Same as APIinstallApp, except it triggers an Update task instead
        self.taskManager.add_task(itemid, moduleid, 2, sourceid, subsourceid, "", "", itemid, False)

    def APIremoveApp(self, itemid, moduleid, sourceid, subsourceid):
        #Same as APIinstallApp, except it triggers a Remove task instead
        self.taskManager.add_task(itemid, moduleid, 1, sourceid, subsourceid, "", "", itemid, False)

    def APIaddSource(self, sourceid, moduleid):
        #Tells the module of moduleid matching to add the source of ID sourceid
        self.taskManager.add_task(sourceid, moduleid, 0, "", "", "", "", itemid, False)

    def APIremoveSource(self, sourceid, moduleid):
        #Same as APIaddSource, except it removes it instead
        self.taskManager.add_task(sourceid, moduleid, 1, "", "", "", "", itemid, False)

    def APIshowTaskConfirmation(self, taskbody, idsadded, idsupdated, idsremoved):
        #Tells GUI to show task confirmation dialog, and then waits for value (True/False), alongside a bonus installs list, to be returned.
        #FIXME: Uh... how DO we even hold code in this context until we return a value from user input?
        return self.modules[self.GUImodule].showTaskConfirmation(taskbody, idsadded, idsupdated, idsremoved)

    def APIgotoID(self, itemid):
        #Tells GUI to go to the 'package page' for ID itemid, that's it.
        self.modules[self.GUImodule].gotoID(itemid)

    def APIrefreshMemory(self):
        #Store calls refreshMemory on EVERY single module that Store knows of
        for module in self.modules:
            self.modules[module].refreshMemory()

    def APIreloadStore(self):
        #Straight up restarts Store
        pass #TODO

    def APIreloadPages(self):
        #Reloads every single Store GUI page that's loaded right now
        self.storeAPI.reloadPkgStates(["all"])
        self.modules[self.GUImodule].reloadPages()

    def APIreloadPkgStates(self, moduleids, packageids=["all"]):
        #moduleids: List of all module IDs to affect
        #packageids: Optional - List of all package IDs to affect

        #Refresh install status of all packageids from all the sources belonging managed the moduleids
        #Also uncache any install statuses for them that are cached

        if moduleids == "all":
            moduleidsloop = self.modules
        else:
            moduleidsloop = moduleids

        for module in moduleids:
            self.modules[module].reloadPkgStates(packageids)

    def APIfullUpdate(self):
        #Run updateApp on every single updatable item
        #TODO: Consolidate all changes into big confirmation
        pass #TODO

    def APIitemSearch(self, searchstring):
        #For each Search module, do a search with searchstring as the search term
        # Then, sort by numeralphabetical based on the human-readable names, though prior
        #Finally, return the itemids in a sorted dictionary with the priorities
        #TODO: Priority levels: ID match, Exact, ID starts with, Starts with, Ends with, ID ends with
        results = {"idmatch": [], "exact": [], "idstarts": [], "starts": [], "ends": [], "idends": []}

        for module in self.search_modules:
            moduletemp = self.search_modules[module].getResults(searchterm)
            moduletemp = dict(moduletemp) #For some reason, not doing this pops it inside the module(s) too on the next line
            moduletemp.pop('status', None)
            try:
                for item in results:
                    results[item] = self.dict_recurupdate(results[item], moduletemp[item])
            except Exception as e:
                #TODO: API for generic errors
                print("DEBUG: {0} failed to search due to the following exception or missing value: {1}".format(module, e))

        #FIXME: Is there not a more efficient way to remove duplicate results? (proritise is over begins with, contains and ends with, begins with over contains and ends with, and contains over ends with)
        #for result in overall_results["exactmatch"]:
            #if result in overall_results["begins"]:
                #overall_results["begins"].pop(result, None)
            #elif result in overall_results["contains"]:
                #overall_results["contains"].pop(result, None)
            #elif result in overall_results["ends"]:
                #overall_results["ends"].pop(result, None)
        #for result in overall_results["begins"]:
            #if result in overall_results["contains"]:
                #overall_results["contains"].pop(result, None)
            #elif result in overall_results["ends"]:
                #overall_results["contains"].pop(result, None)
        #for result in overall_results["contains"]:
            #if result in overall_results["ends"]:
                #overall_results["ends"].pop(result, None)

        return results


    def APIgetAutoUpdateOn(self, moduleid):
        #Module returns true/false for if automatic updates are on
        pass #TODO

    def APIgetAutoUpdateBandwidthOn(self, moduleid):
        #Module returns float for automatic updates bandwidth
        pass #TODO


    def APIgetItemIDs(self, categories):
        #Gets all available item IDs from each module, belonging to the category ID category provides (if ['all'], all available item IDs without filtering), and returns them as a dictionary of listings per category
        result = {}
        for item in categories:
            result[item] = []
            for module in self.modules:
                if module.startswith("packagemgmt-"):
                    for cateresult in self.modules[module].getCategoryIDs(item):
                        if cateresult not in result[item]:
                            result[item].append(cateresult)

        return result

    def APIgetFallbackIconLocation(self, iconlocal, iconuri, itemid): #TODO: Move icons from /tmp to ~/.cache, and set a disk space cap on it
        #In case the icon set cannot be used to supply an icon:
        # try to use the file path provided by iconlocal to provide the icon image
        # otherwise try retrieving it from iconuri and then returning that filepath
        # if all else fails, return None

        if iconlocal != "" and os.path.isfile(iconlocal):
            return iconlocal
        else:
            try:
                if iconuri == "":
                    raise
                #Download the application icon
                if not os.path.isfile(self.cachedir+"/icons/"+itemid):
                    r=requests.get(iconuri, headers=self.reqHeaders)
                    with open(self.cachedir+"/icons/"+itemid, "wb") as f:
                        f.write(r.content)
                    time.sleep(0.1) #Can return too early and cause an exception, thus sleep
                return self.cachedir+"/icons/"+itemid
            except Exception as e:
                print(_("Failed to retrieve the icon of "+itemid+" because: %s") % e)
                return None


    # API functions passed from Store into TasksAPI
    ##############################################
    def APIaddConfirmedTask(self, itemid, moduleid, operation, sourceid, subsourceid, becauseof="", dependson="", directto=""):
        #Add a task but make it confirmed right from the start
        self.taskManager.add_task(itemid, moduleid, operation, sourceid, subsourceid, becauseof, dependson, directto, True)

    def APIdeleteTask(self, taskid):
        #Delete the task matching taskid
        moduleid = self.taskManager.tasks["order"][taskid].moduleid
        itemid = self.taskManager.tasks["order"][taskid].itemid
        self.taskManager.tasks[moduleid].pop(taskid, None)
        self.taskManager.tasks["order"].pop(taskid, None)
        self.storeAPI.reloadPkgStates([moduleid], [itemid])

    def APIrunTask(self, taskbody):
        #Run a task, matching taskbody
        if taskbody.operation == 0: #Install/Add
            self.modules[moduleid].task_install_package(taskbody)
        elif taskbody.operation == 1: #Remove
            self.modules[moduleid].task_remove_package(taskbody)
        elif taskbody.operation == 2: #Update
            self.modules[moduleid].task_update_package(taskbody)

    def APIshowFailure(self, taskbody, exceptionstr):
        #Show a failure dialog in the GUI to indicate that an item failed to install/remove/update/etc. and indicate the why
        print("DEBUG: {0} failed: {1}".format(taskbody.moduleid+":"+taskbody.itemid+":"+taskbody.sourceid+":"+taskbody.subsourceid+":"+str(taskbody.operation), exceptionstr)) #FIXME: Temporary method
        pass #TODO

    def APIcleanupModule(self, moduleid):
        #Trigger post-task cleanup in the module matching moduleid
        self.modules[moduleid].cleanupModule()


    # API functions passed from Store into SettingsAPI
    ##############################################
    def APIchangeAutoUpdateOn(self, moduleid, newvalue):
        #Module changes automatic updates value to newvalue (bool)
        pass #TODO

    def APIchangeAutoUpdateBandwidthOn(self, moduleid, newfloat):
        #Module changes automatic updates bandwidth to newfloat (float)
        pass #TODO

    def APIgetAutoUpdateSupported(self, moduleid):
        #Get module's value for autoUpdateSupported
        pass #TODO

    def APIgetAutoUpdateBandwidthSupported(self, moduleid):
        #Get module's value for autoUpdateBandwidthSupported
        pass #TODO

    def APIgetPackageMgmtModulesInfo(self, moduleid="all"):
        #Gets dictionary of information about the package module matching moduleid, or if all then all the package modules
        pass #TODO


    # Main functionality of Store Brain
    ##############################################
    def __init__(self):
        self.taskManager = TaskManager()

        self.last_module_path = ""
        self.modules = {}
        #TODO: Store each module with IDs, such as package module 'apt' having an ID of pmapt
        #Then, have the module storage be something along the lines of {..., 'pmapt': self.new_module(path), ...} so the API knows which module to call for what

        #Prepare the APIs and map the calls:
        # Generic
        self.genericapi = StoreGenericAPI()
        self.genericapi.getDefaultItemInformation = self.APIgetDefaultItemInformation
        self.genericapi.getSpecificItemInformation = self.APIgetSpecificItemInformation
        self.genericapi.getAvailableSources = self.APIgetAvailableSources
        self.genericapi.getCuratedJSON = self.APIgetCuratedJSON
        self.genericapi.cancelTask = self.APIcancelTask
        self.genericapi.installApp = self.APIinstallApp
        self.genericapi.updateApp = self.APIupdateApp
        self.genericapi.removeApp = self.APIremoveApp
        self.genericapi.addSource = self.APIaddSource
        self.genericapi.removeSource = self.APIremoveSource
        self.genericapi.showTaskConfirmation = self.APIshowTaskConfirmation
        self.genericapi.gotoID = self.APIgotoID
        self.genericapi.refreshMemory = self.APIrefreshMemory
        self.genericapi.reloadStore = self.APIreloadStore
        self.genericapi.reloadPages = self.APIreloadPages
        self.genericapi.reloadPkgStates = self.APIreloadPkgStates
        self.genericapi.fullUpdate = self.APIfullUpdate
        self.genericapi.itemSearch = self.APIitemSearch
        self.genericapi.getAutoUpdateOn = self.APIgetAutoUpdateOn
        self.genericapi.getAutoUpdateBandwidthOn = self.APIgetAutoUpdateBandwidthOn
        self.genericapi.getItemIDs = self.APIgetItemIDs

        self.genericapi.getFallbackIconLocation = self.APIgetFallbackIconLocation
        self.genericapi.dict_recurupdate = self.dict_recurupdate

        # Tasks
        self.tasksapi = StoreTasksAPI()
        self.tasksapi.addConfirmedTask = self.APIaddConfirmedTask
        self.tasksapi.deleteTask = self.APIdeleteTask
        self.tasksapi.runTask = self.APIrunTask
        self.tasksapi.showFailure = self.APIshowFailure
        self.tasksapi.cleanupModule = self.APIcleanupModule

        # Settings
        self.settingsapi = StoreSettingsAPI()
        self.settingsapi.changeAutoUpdateOn = self.APIchangeAutoUpdateOn
        self.settingsapi.getAutoUpdateSupported = self.APIgetAutoUpdateSupported
        self.settingsapi.changeAutoUpdateBandwidthOn = self.APIchangeAutoUpdateBandwidthOn
        self.settingsapi.getAutoUpdateBandwidthSupported = self.APIgetAutoUpdateBandwidthSupported
        self.settingsapi.getPackageMgmtModulesInfo = self.APIgetPackageMgmtModulesInfo

        #Load the GUI while it loads
        self.modules["gui"] = self.new_module("/usr/lib/feren-storium/modules/gui/gtk3-demo")
        # TODO: Have GUI be determined by gsettings

        self.cachedir = os.path.expanduser("~")+"/.cache/feren-storium"
        #Make the folder if it doesn't exist
        if not os.path.isdir(self.cachedir):
            os.mkdir(self.cachedir)
        if not os.path.isdir(self.cachedir + "/icons"):
            os.mkdir(self.cachedir + "/icons")

        self.modules["gui"].prepareGUI()
        self.post_init()
        self.modules["gui"].showGUIHold()


    def post_init(self):
        thread = Thread(target=self._post_init,
                        args=())
        thread.daemon = True
        thread.start()

    def _post_init(self):
        #Load in the modules
        # TODO: Have the loaded modules be determined by gsettings
        self.load_modules()


        #Headers information for requests
        self.reqHeaders = {'user-agent': 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/94.0.4606.114 Safari/537.36'}




        #TODO: Use idle_add to exit the splash screen and load the pages
        #GLib.idle_add(self.__post_init)



        self.modules["gui"].GUILoadingFinished()







    def refresh_modules(self):
        for module in self.localpkgmgmt_modules:
            try:
                self.localpkgmgmt_modules[module].refresh_memory()
            except Exception as e:
                print(e)
        for module in self.pkgmgmt_modules:
            try:
                self.pkgmgmt_modules[module].refresh_memory()
            except Exception as e:
                print(e)
        for module in self.pkginfo_modules:
            try:
                self.pkginfo_modules[module].refresh_memory()
            except Exception as e:
                print(e)
        for module in self.search_modules:
            try:
                self.search_modules[module].refresh_memory()
            except Exception as e:
                print(e)
        for module in self.sourceinfo_modules:
            try:
                self.sourceinfo_modules[module].refresh_memory()
            except Exception as e:
                print(e)
        for module in self.settings_modules:
            try:
                self.settings_modules[module].refresh_memory()
            except Exception as e:
                print(e)
                
                
    def refresh_overall_package_data(self):
        #Make the generic module make a {category: [ids]} dictionary for homepage and whatnot
        self.pkginfo_modules[self.generic_module].build_categories_ids()
        #Build each module's ID lists
        for module in self.pkginfo_modules:
            self.pkginfo_modules[module].build_ids_list()
        
            
        
    def item_search(self, searchterm):
        overall_results = {}
        temp_var = {}
        for module in self.search_modules:
            temp_var = self.search_modules[module].getResults(searchterm)
            temp_var = dict(temp_var) #For some reason, not doing this pops it inside the module(s) too on the next line
            temp_var.pop('status', None)
            overall_results = self.dict_recurupdate(overall_results, temp_var)
            
        #FIXME: Is there not a more efficient way to remove duplicate results? (proritise is over begins with, contains and ends with, begins with over contains and ends with, and contains over ends with)
        for result in overall_results["exactmatch"]:
            if result in overall_results["begins"]:
                overall_results["begins"].pop(result, None)
            elif result in overall_results["contains"]:
                overall_results["contains"].pop(result, None)
            elif result in overall_results["ends"]:
                overall_results["ends"].pop(result, None)
        for result in overall_results["begins"]:
            if result in overall_results["contains"]:
                overall_results["contains"].pop(result, None)
            elif result in overall_results["ends"]:
                overall_results["contains"].pop(result, None)
        for result in overall_results["contains"]:
            if result in overall_results["ends"]:
                overall_results["ends"].pop(result, None)
            
        return overall_results
    
    def dict_alphasort(self, d):
        sortedkeys = {}
        #Sort the search results
        for result in sorted(d.keys(), key=lambda x:x.lower()):
            sortedkeys[result] = d[result]
        return sortedkeys
    
    def dict_recurupdate(self, d, u): # I'm sure it's a recursive dictionary updater function, from what I can read of this function
        for k, v in u.items():
            if isinstance(v, collections.abc.Mapping):
                d[k] = self.dict_recurupdate(d.get(k, {}), v)
            else:
                d[k] = v
        return d
    
    
    def module_type_query(self, moduleslist, packagetype, addgeneric=True): # Get modules out of modules dict that can handle package type queried
        results = []
        
        for item in moduleslist:
            if moduleslist[item].modulename == self.generic_module and addgeneric != True:
                continue
            if packagetype in moduleslist[item].types_supported or "all" in moduleslist[item].types_supported:
                results.append(moduleslist[item])
        
        return results
    
    
    def add_to_packageinfo(self, packageid):
        # Add package name to all packagestorages of modules that can house this package
        for module in self.pkgmgmt_modules:
            try:
                self.pkgmgmt_modules[module].pkgstorage_add(packageid)
            except:
                pass
    
    
    def get_sources(self, packagename):
        #Get sources of modules
        
        #Package information works like this:
        # - all: All sources information
        # - sourcenamehere: Information specific to the source
        
        #packagename: package name
        #pkgtype: package type (e.g.: apt, snap...)
        #sourcename: Internal name of source
        #  (subsources don't get specific information)
        
        genericiteminfo = {}
        allsources = {}
        sourceslist = []
        nameslist = [] #Translated names
        
        try:
            genericiteminfo = self.pkginfo_modules[self.generic_module].getInfo(packagename, "all") #No source specified so that we can get all the extra information pieces
        except:
            return [], []
        
        #First collect all possible sources into a dict
        for pkgtype in genericiteminfo["type-importance"]:
            modules = self.module_type_query(self.pkginfo_modules, pkgtype, False)
            
            allsources[pkgtype] = {}
            
            if modules == []:
                continue #Skip to next pkgtype if no modules available
            
            for module in modules:
                allsources[pkgtype][module.modulename] = module.getSourceList(packagename, pkgtype)
                
        #Now get an accurate list using the module to check        
        for pkgtype in allsources:
            mgmtmodules = self.module_type_query(self.pkgmgmt_modules, pkgtype, False)
            
            for module in allsources[pkgtype]:
                for mgmtmodule in mgmtmodules:
                    try:
                        for actualsource in mgmtmodule.sourceQuery(packagename, pkgtype, allsources[pkgtype][module]):
                            nameslist.append(actualsource + " (" + mgmtmodule.modulename + ", " + pkgtype + ")") #Temporary, TODO: Translate name via module
                            sourceslist.append(mgmtmodule.modulename + ":" + pkgtype + ":" + actualsource)
                    except Exception as e:
                        print("GET SOURCES DEBUG: {0} couldn't check sourcelist {1} from package type {2}: {3}".format(mgmtmodule.humanreadabletitle, str(allsources[pkgtype][module]), pkgtype, e))
                        #Make sure nothing gets in there that shouldn't
                        if len(nameslist) > len(sourceslist):
                            nameslist.pop(-1)
                        elif len(nameslist) < len(sourceslist):
                            sourceslist.pop(-1)
                    
                
        return sourceslist, nameslist
    
    def get_subsources(self, sourceid, packagename):
        subsourceslist = []
        nameslist = [] #Translated names
        
        modulename, pkgtype, source = sourceid.split(":")
        
        try:
            for subsource in self.pkgmgmt_modules[modulename].get_subsources(packagename, pkgtype, source):
                nameslist.append(subsource) #Temporary, TODO: Translate name via module
                subsourceslist.append(subsource)
        except Exception as e:
            print("GET SUBSOURCES DEBUG: {0} couldn't get a subsources list for {1} on sourceid {2}: {3}".format(modulename, packagename, sourceid, e))
            return [], []
            
        return subsourceslist, nameslist
    
    
    def get_package_moduleorder(self, packagename):
        try:
            return self.pkginfo_modules[self.generic_module].getPackageJSON()[packagename]["type-importance"]
        except:
            pass
        
        
    def get_generic_item_info(self, packagename, pkgtype): #Get generic package information
        #Note: Generic only uses the 'all' source
        try:
            genericinfo = self.pkginfo_modules[self.generic_module].getInfo(packagename, pkgtype, "all") #We use 'all' as a placebo since it's not important in a generic module
            return genericinfo
        except:
            raise StoreBrainException(_("No information was found for %s") % packagename)
        
    
    def get_item_info_specific(self, packagename, pkgtype, sourcename, generictoo=False): #Get package information for specific source (no generic)
        #Package information works like this:
        # - all: All sources information
        # - sourcenamehere: Information specific to the source
        
        #packagename: package name
        #pkgtype: package type (e.g.: apt, snap...)
        #sourcename: Internal name of source
        #  (subsources don't get specific information)
        
        modules = self.module_type_query(self.pkginfo_modules, pkgtype, False)
        iteminfo = {}
        
        if generictoo == True:
            iteminfo = self.get_generic_item_info(packagename, pkgtype)
        
        for module in modules:
            try:
                iteminfo = self.dict_recurupdate(iteminfo, module.getInfo(packagename, pkgtype, sourcename))
            except Exception as e:
                print("GET ITEM INFO DEBUG: {0} couldn't get item information for {1} from package type {2} of source name {3}: {4}".format(module.humanreadabletitle, packagename, pkgtype, sourcename, e))
                pass
            
        if iteminfo == {}:
            raise StoreBrainException(_("No information was provided for {0} of type {1} in source {2}".format(packagename, pkgtype, sourcename)))
        
        return iteminfo
        
    
    def get_item_info_default(self, packagename): #Get default package information
        #Package information works like this:
        # - all: All sources information
        # - sourcenamehere: Information specific to the source
        
        #packagename: package name
        #pkgtype: package type (e.g.: apt, snap...)
        #sourcename: Internal name of source
        #  (subsources don't get specific information)
        
        #TODO: Make modules provide fallback information
        iteminfo = {}
        genericiteminfo = {}
        
        try:
            genericiteminfo = self.pkginfo_modules[self.generic_module].getInfo(packagename, "all") #No source specified so that we can get all the extra information pieces
            iteminfo = copy.deepcopy(genericiteminfo) #Python3's normal behaviour is to link them together, thus meaning updating one updates the other, which we DON'T want
        except Exception as e:
            print(e)
            pass
        
        for pkgtype in iteminfo["type-importance"]:
            modules = self.module_type_query(self.pkginfo_modules, pkgtype, False)
            
            if modules == []:
                continue #Skip to next module if no modules available
            
            for module in modules:
                skipahead = False
                resultinfo = {}
                
                try:
                    if "all" not in iteminfo:
                        iteminfo["all"] = {}
                    iteminfo["all"] = self.dict_recurupdate(iteminfo["all"], module.getInfo(packagename, pkgtype, "all"))
                except:
                    pass
                if "all" in iteminfo:
                    resultinfo = iteminfo["all"]
                
                tempsources = module.getSourceList(packagename, pkgtype)
                
                for sourcename in tempsources:
                    if skipahead == True:
                        break
                    
                    if sourcename not in iteminfo:
                        iteminfo[sourcename] = {}
                    try:
                        iteminfo[sourcename] = self.dict_recurupdate(iteminfo[sourcename], module.getInfo(packagename, pkgtype, sourcename))
                        resultinfo = self.dict_recurupdate(resultinfo, iteminfo[sourcename])
                        skipahead = True #We only want the first possible source's information, that's it
                    except Exception as e:
                        print("GET ITEM INFO DEBUG: {0} couldn't get item information for {1} from package type {2}: {3}".format(module.humanreadabletitle, packagename, pkgtype, e))
                        pass
                
            if iteminfo != genericiteminfo:                
                return resultinfo #We're done here.
        
        
        raise StoreBrainException(_("No information was found for %s") % packagename)
        
        
    
    def package_module(self, packagetype, name=False): #TODO: Remove
        #Return the first one we find's name
        for module in self.pkgmgmt_modules:
            if packagetype in self.pkgmgmt_modules[module].types_supported:
                if name:
                    return module
                else:
                    return self.pkgmgmt_modules[module]
        raise StoreBrainException(_("No package module was found for managing %s") % packagetype)
        
    def local_package_module(self, packagetype, name=False):
        #Return the first one we find's name
        for module in self.localpkgmgmt_modules:
            if packagetype in self.localpkgmgmt_modules[module].types_supported:
                if name:
                    return module
                else:
                    return self.localpkgmgmt_modules[module]
        raise StoreBrainException(_("No local package module was found for managing %s") % packagetype)
        
    def package_info_module(self, packagetype, name=False):
        #Return the first one we find's name
        for module in self.pkginfo_modules:
            if packagetype in self.pkginfo_modules[module].types_provided:
                if name:
                    return module
                else:
                    return self.pkginfo_modules[module]
        raise StoreBrainException(_("No package info module was found for %s") % packagetype)
        
    def source_info_module(self, sourcetype, name=False):
        #Return the first one we find's name
        for module in self.sourceinfo_modules:
            if sourcetype in self.sourceinfo_modules[module].types_provided:
                if name:
                    return module
                else:
                    return self.sourceinfo_modules[module]
        for module in self.sourceinfo_modules: #TODO: Figure out how to combine outputs
            if "all" in self.sourceinfo_modules[module].types_provided:
                if name:
                    return module
                else:
                    return self.sourceinfo_modules[module]
        raise StoreBrainException(_("No source info module was found for %s") % sourcetype)
    
    
    
    def set_progress(self, packagename, packagetype, value): #TODO: Change into being part of Tasks management
        self.gui_module.set_progress(packagename, packagetype, value)

        
    def run(self):
        signal.signal(signal.SIGINT, signal.SIG_DFL)
     
     

     
     
if __name__ == "__main__":
    app = StoreBrain()
    app.run()
    
