#!/usr/bin/python3

import sys
import os
import importlib
import signal
from threading import Thread
import gi
from gi.repository import GLib
import gettext
import getpass
import collections.abc

class StoreBrainException(Exception): # Name this according to the module to allow easier debugging
    pass

#TODO: Move overall_package_data, etc. to be 'generic' in Storium, and each other one's ones in the modules themselves, and maybe make Generic Modules part of THIS file

#This class here is the main brains that connect the pieces of code together per each module
class StoreModuleContainer():
    def __init__(self, storebrain, path):
        if not os.path.isfile(path + "/module.py"):
            raise StoreBrainException("Invalid module")
        with open(path + "/module.py", 'r') as modulecheck:
            check = False
            for i in modulecheck:
                if "class main(" in i:
                    check = True
            if check == False:
                raise StoreBrainException("Invalid module")
        
        self.path = path
        sys.path.insert(0, path) #Adds the module directory to the path for this class, so the next part knows where module.py is
        try:
            import module
            importlib.reload(module) #Otherwise only one module will be loaded across all variables
            #Imports the 'module.py' file of the folder
            self.main = module.main(storebrain)
        except Exception as e:
            sys.path.remove(path)
            raise StoreBrainException(e)
        
        self.main.modulename = path.split("/")[-1]
        
        sys.path.remove(path)


class StoreBrain():
    #Load the initial modules
    def load_modules(self):
        MODULES_DIR = "/usr/lib/feren-storium/modules"
        
        #TODO: Make these lists be managed by gsettings or similar
        if os.path.exists(MODULES_DIR):
            for dir_name in sorted(os.listdir(MODULES_DIR+"/localpackagemgmt")):
                path = os.path.join(MODULES_DIR+"/localpackagemgmt", dir_name)
                module = None
                try:
                    module = StoreModuleContainer(self, path)
                    self.localpkgmgmt_modules[dir_name] = module.main
                except Exception as e:
                    print("Failed to load local package management module %s: \n%s\n" % (dir_name, e))
            for dir_name in sorted(os.listdir(MODULES_DIR+"/packagemgmt")):
                path = os.path.join(MODULES_DIR+"/packagemgmt", dir_name)
                module = None
                try:
                    module = StoreModuleContainer(self, path)
                    self.pkgmgmt_modules[dir_name] = module.main
                except Exception as e:
                    print("Failed to load package management module %s: \n%s\n" % (dir_name, e))
            for dir_name in sorted(os.listdir(MODULES_DIR+"/packageinfo")):
                path = os.path.join(MODULES_DIR+"/packageinfo", dir_name)
                module = None
                try:
                    module = StoreModuleContainer(self, path)
                    self.pkginfo_modules[dir_name] = module.main
                except Exception as e:
                    print("Failed to load package information module %s: \n%s\n" % (dir_name, e))
            for dir_name in sorted(os.listdir(MODULES_DIR+"/sourceinfo")):
                path = os.path.join(MODULES_DIR+"/sourceinfo", dir_name)
                module = None
                try:
                    module = StoreModuleContainer(self, path)
                    self.sourceinfo_modules[dir_name] = module.main
                except Exception as e:
                    print("Failed to load source information module %s: \n%s\n" % (dir_name, e))
            for dir_name in sorted(os.listdir(MODULES_DIR+"/settings")):
                path = os.path.join(MODULES_DIR+"/settings", dir_name)
                module = None
                try:
                    module = StoreModuleContainer(self, path)
                    self.settings_modules[dir_name] = module.main
                except Exception as e:
                    print("Failed to load settings module %s: \n%s\n" % (dir_name, e))
    
    
    def __init__(self):
        self.gui_module = StoreModuleContainer(self, "/usr/lib/feren-storium/modules/gui/gtk3-demo").main
        # TODO: Have it be determined by gsettings
        #self.settings_gui_module = StoreModuleContainer(self, "/usr/lib/feren-storium/modules/settings-gui/gtk3-demo").main
        # TODO: Have it be determined by gsettings
        self.localpkgmgmt_modules = {}
        self.pkgmgmt_modules = {}
        self.pkginfo_modules = {}
        self.sourceinfo_modules = {}
        self.settings_modules = {}
        
        
        #For modules and GUI - mainly source selection dropdown
        self.current_package_viewed = ""
        self.current_module_selected = ""
        self.current_pkgsource_selected = ""
        
        
        self.tempdir = "/tmp/feren-storium-"+getpass.getuser()
        #Make the folder if it doesn't exist
        if not os.path.isdir(self.tempdir):
            os.mkdir(self.tempdir)
        if not os.path.isdir(self.tempdir + "/icons"):
            os.mkdir(self.tempdir + "/icons")
        
        #TODO: Remove this later on
        self.debug_module = StoreModuleContainer(self, "/usr/lib/feren-storium/modules/tempdebug").main
        
        self.load_modules()
        
        # For search and whatnot
        self.overall_package_data = {}
        self.package_name_categories = {}
        self.refresh_overall_package_data()
                
                
    def refresh_overall_package_data(self):
        self.overall_package_data = {}
        self.package_name_categories = {}
        #Refill overall package data using modules
        for module in self.pkginfo_modules:
            self.overall_package_data[module] = self.pkginfo_modules[module].getPackageJSON()
            
        #Also update package_name_categories for layouting
        for module in self.overall_package_data:
            for item in self.overall_package_data[module]:
                try:
                    self.package_name_categories[item] = self.overall_package_data[module][item]["category"]
                except:
                    pass
            
        
    def item_search(self, searchterm):
        searchresults = []
        #FIXME: Is there not a more efficient way to do this?
        #First check: Is the search term literally the name of the package or the real name?
        for item in self.package_name_categories:
            if searchterm == self.get_item_info(item, "generic:generic")["realname"]:
                searchresults.append(item)
        if searchterm in self.package_name_categories:
            searchresults.append(searchterm)
        #Second check: Do any names start with the search term?
        for item in self.package_name_categories:
            if item.startswith(searchterm) or self.get_item_info(item, "generic:generic")["realname"].startswith(searchterm):
                searchresults.append(item)
        #Third check: Do any names contain the search term?
        for item in self.package_name_categories:
            if searchterm in item or searchterm in self.get_item_info(item, "generic:generic")["realname"]:
                searchresults.append(item)
        #Remove duplicates from list using a python3 trick
        searchresults = list(dict.fromkeys(searchresults))
        
        return searchresults
    
    
    def dict_recurupdate(self, d, u): # I'm sure it's a recursive dictionary updater function, from what I can read of this function
        for k, v in u.items():
            if isinstance(v, collections.abc.Mapping):
                d[k] = self.dict_recurupdate(d.get(k, {}), v)
            else:
                d[k] = v
        return d
    
    
    def add_to_packageinfo(self, packagename, packagesource):
        # Add package name to all packagestorages of modules that can house this package
        for module in self.pkgmgmt_modules:
            try:
                self.pkgmgmt_modules[module].pkgstorage_add(packagename, packagesource)
            except:
                pass
    
    
    def get_sources(self, packagename):
        sourcesdict = {}
        #"modulename:internalname": "dropdown human readable name"
        for module in self.pkgmgmt_modules:
            sources = []
            try:
                if packagename in self.pkgmgmt_modules[module].packagestorage:
                    sources = self.pkgmgmt_modules[module].get_sources(packagename)
                    for source in sources:
                        sourcesdict[module + ":" + source] = self.source_info_module(module).getSourceSelectName(module, source)
            except:
                pass
        return sourcesdict
    
    def get_subsources(self, sourceid, sourcetype):
        subsourcesdict = {}
        #"internalname": "dropdown human readable name"
        
        try:
            sources = self.source_info_module(sourceid).getSubSources(sourceid, sourcetype)
            for source in sources:
                subsourcesdict[source] = self.source_info_module(sourcetype).getSourceSelectName(sourceid, sourcetype, source)
        except:
            subsourcesdict = {}
        return subsourcesdict
    
    
    def get_package_sourceorder(self, packagename):
        for module in self.overall_package_data:
            if packagename in self.overall_package_data[module]:
                try:
                    return self.overall_package_data[module][packagename]["order-of-source-importance"]
                except:
                    pass
            
    
    def get_item_info(self, packagename, modulename, packagesource):
        extrainfo = self.pkginfo_modules[modulename].getInfo(packagename, packagesource)
        
        for module in self.overall_package_data:
            if packagename in self.overall_package_data[module]:
                return self.dict_recurupdate(self.overall_package_data[module][packagename], extrainfo)
        
        raise StoreBrainException(_("No information was found for %s") % packagename)
    
    def set_progress(self, packagename, packagetype, value):
        self.gui_module.set_progress(packagename, packagetype, value)
        
    
    def package_module(self, packagetype, name=False):
        #Return the first one we find's name
        for module in self.pkgmgmt_modules:
            if packagetype in self.pkgmgmt_modules[module].types_managed:
                if name:
                    return module
                else:
                    return self.pkgmgmt_modules[module]
        raise StoreBrainException(_("No package module was found for managing %s") % packagetype)
        
    def local_package_module(self, packagetype, name=False):
        #Return the first one we find's name
        for module in self.localpkgmgmt_modules:
            if packagetype in self.localpkgmgmt_modules[module].types_managed:
                if name:
                    return module
                else:
                    return self.localpkgmgmt_modules[module]
        raise StoreBrainException(_("No local package module was found for managing %s") % packagetype)
        
    def package_info_module(self, packagetype, name=False):
        #Return the first one we find's name
        for module in self.pkginfo_modules:
            if packagetype in self.pkginfo_modules[module].types_provided:
                if name:
                    return module
                else:
                    return self.pkginfo_modules[module]
        raise StoreBrainException(_("No package info module was found for %s") % packagetype)
        
    def source_info_module(self, sourcetype, name=False):
        #Return the first one we find's name
        for module in self.sourceinfo_modules:
            if sourcetype in self.sourceinfo_modules[module].types_provided:
                if name:
                    return module
                else:
                    return self.sourceinfo_modules[module]
        for module in self.sourceinfo_modules: #TODO: Figure out how to combine outputs
            if "all" in self.sourceinfo_modules[module].types_provided:
                if name:
                    return module
                else:
                    return self.sourceinfo_modules[module]
        raise StoreBrainException(_("No source info module was found for %s") % sourcetype)
        
        
    def run_module(self, module):
        thread = Thread(target=self._run_module,
                        args=(module,))
        thread.daemon = True
        thread.start()

    def _run_module(self, module):
        GLib.idle_add(self.__run_module, module)
        
    def __run_module(self, module):
        module.init()
        
    def run(self):
        signal.signal(signal.SIGINT, signal.SIG_DFL)
        
        self.run_module(self.debug_module)
        
        self.gui_module.init()
     
     
     
if __name__ == "__main__":
    app = StoreBrain()
    app.run()
    