#!/usr/bin/python3

import sys
import os
import importlib
import signal
from threading import Thread
import gi
from gi.repository import GLib
import gettext
import getpass
import collections.abc

import requests #Grabbing files from internet

class StoreBrainException(Exception): # Name this according to the module to allow easier debugging
    pass

#TODO: Change sources usage for package information to package module usage

#This class here is the main brains that connect the pieces of code together per each module
class StoreModuleContainer():
    def __init__(self, storebrain, path):
        self.path = None
        self.main = None
        if 'module' in sys.modules:
            sys.modules.pop('module')
        
        if not os.path.isfile(path + "/module.py"):
            raise StoreBrainException("Invalid module")
        with open(path + "/module.py", 'r') as modulecheck:
            check = False
            for i in modulecheck:
                if "class main(" in i:
                    check = True
            if check == False:
                raise StoreBrainException("Invalid module")
        
        self.path = path
        sys.path.insert(0, path) #Adds the module directory to the path for this class, so the next part knows where module.py is
        try:
            import module
            importlib.reload(module) #Otherwise only one module will be loaded across all variables
            
            if module.should_load() == True:
                #Imports the 'module.py' file of the folder
                self.main = module.main(storebrain)
                self.main.modulename = path.split("/")[-1]
        except Exception as e:
            sys.path.remove(path)
            self.main = None
            raise StoreBrainException(e)
        
        
        sys.path.remove(path)
        
        
class StoreTasks():
    #Each task item will be this:
    # "module:packagename:operation": {"type": "item/packageitem/source", "module": "modulenamehere", "packagename": "packagenamehere", "operation": 0/1/2, "progress": "0-100", "directto": "packagepageidhere", "realname": "Actual Name for notifications", "source": source, "subsource": subsource, "bonuses": [listgobrrr]}
    #
    # type: Is it an item (application) or source (source) or package file item (packageitem)?
    # module: Name of module that'll manage the item (module that'll manage the source on source)
    # packagename: Storium ID of package (Storium ID of source on source)
    # operation: 0 for Install, 1 for Update, 2 for Remove (0 for Add, 1 for Remove on source)
    # progress: int from 0 to 100 of progress so far
    # directto: On click of Task, redirect to packagepage with id (value goes here)
    # realname: Human readable name of item for use in Notifications
    # source: Source to obtain the application from ("" on source)
    # subsource: Subsource to obtain the application from ("" on source)
    # bonuses: List of bonuses to add ([] on source)
    
    def __init__(self):
        self.currenttasks = {} #Tasks lists (per module)
        self.currenttask = {} #ID of current task (per module)
        self.dontcontinue = False #Used for when a logoff is initiated, or Store is pending a restart during updates, as the goal is to stop after the current tasks
        self.lockedtasklist = {} #Use when dontcontinue is on to make sure any added Tasks DO NOT get done (main point is to use this whenever the user requests logout, etc.)
        #GObject.threads_init()   Leftover from New Store (prior project) - might come in handy, idk.
        
        self.overalltasksorder = [] #For GUI organising of tasks
        
        self.currenttaskmodules = [] #Current modules in use for managing tasks (for multi-thread tasks management)
        self.currentpkgtaskmodules = [] #Same as the above, but for package file tasks
        
    def add_task_item_ifnotexists(self, module): #Adds Tasks section if it's not a section yet
        if module not in self.currenttasks:
            self.currenttasks[module] = {}
        if module not in self.currenttask:
            self.currenttask[module] = ""
        if module not in self.lockedtasklist: #To make things easier to not break
            self.lockedtasklist[module] = {}
    
        
    def add_task(self, module, packagename, operation, realname, source, subsource, bonuses=[]): #Add package management task
        self.add_task_item_ifnotexists(module)
        
        newtask = module + ":" + packagename + ":" + str(operation)
        if not newtask in self.currenttasks[module]:
            self.currenttasks[module][newtask] = {"type": "item", "module": module, "packagename": packagename, "operation": operation, "progress": 0, "directto": packagename, "realname": realname, "source": source, "subsource": subsource, "bonuses": bonuses}
            self.overalltasksorder.append(newtask)
            
        self.begin_tasks() #Trigger Tasks action if it isn't already in action
        
    def add_task_package(self, module, packagename, operation, realname, source, subsource): #Add package management task for a package file
        self.add_task_item_ifnotexists(module)
        
        newtask = module + ":" + packagename + ":" + str(operation)
        if not newtask in self.currenttasks[module]:
            self.currenttasks[module][newtask] = {"type": "packageitem", "module": module, "packagename": packagename, "operation": operation, "progress": 0, "directto": packagename, "realname": realname, "source": source, "subsource": subsource, "bonuses": []}
            self.overalltasksorder.append(newtask)
            
        self.begin_tasks()
        
    def add_task_source(self, module, packagename, operation, realname, source, subsource): #Add source management task
        self.add_task_item_ifnotexists(module)
        
        newtask = module + ":" + packagename + ":" + str(operation)
        if not newtask in self.currenttasks[module]:
            self.currenttasks[module][newtask] = {"type": "source", "module": module, "packagename": packagename, "operation": operation, "progress": 0, "directto": "", "realname": realname, "source": source, "subsource": subsource, "bonuses": []}
            self.overalltasksorder.append(newtask)
            
        self.begin_tasks()
    
        
    def cancel_task(self, module, packagename): #Cancel task
        for item in self.currenttasks[module]:
            if item.startswith(module+":"+packagename+":"):
                targettask = item
                break #Exit the loop
        if self.currenttask[module] == item:
            print("TASKS DEBUG ("+module+"): Couldn't cancel task - task is already in progress")
            return
        self.currenttasks[module].pop(item)
        self.lockedtasklist[module].pop(item, None)
        self.overalltasksorder.pop(self.overalltasksorder.index(item))
        print("TASKS DEBUG ("+module+"): Cancelled a task")
        
        self.storebrain.gui_module.refresh_tasks()
            
        
    def begin_tasks(self):
        self.storebrain.gui_module.refresh_tasks() #Refresh Tasks view and such in GUI
        
        for module in self.currenttasks: #Initiate tasks working for all modules
            thread = Thread(target=self._begin_tasks,
                            args=(module,))
            thread.daemon = True
            thread.start()
        
    def _begin_tasks(self, module):
        if self.currenttask[module] != "":
            return #It's already running, don't bother running it again
        
        
        taskoffset = 0 #Increase if we need to skip items because dontcontinue
        while self.currenttasks[module] != {}:
            
            print("TASKS DEBUG ("+module+"): currenttasks is", self.currenttasks[module])
            print("TASKS DEBUG: overalltasksorder is", self.overalltasksorder)
            if self.dontcontinue == True and self.lockedtasklist[module] == {}:
                #Abort loop if we're out of locked tasks list items
                break
            
            if len(self.currenttasks[module]) <= taskoffset:
                taskoffset = 0 #Reset taskoffset if it's higher than the number of tasks
            
            #Get the placement of our item in self.overalltasksorder
            targettask = list(self.currenttasks[module].keys())[taskoffset]
            ttaskoverallindex = self.overalltasksorder.index(targettask)
            
            if targettask in self.lockedtasklist[module] or self.lockedtasklist[module] == {}:
                self.do_task(targettask, module, self.storebrain.gui_module.refresh_tasks, self.storebrain.set_progress)
                self.currenttasks[module].pop(targettask)
                self.overalltasksorder.pop(ttaskoverallindex)
                self.storebrain.gui_module.refresh_tasks()
            else:
                taskoffset += 1 #Skip the task if dontcontinue is on and task isn't in the locked task list
            
            
        self.currenttask[module] = "" #Free up the function for a future calling since we're gonna return on this so it'll need recalling
        print("TASKS DEBUG ("+module+"): currenttasks is all done, returning.")
        
        
    def do_task(self, task, module, gui_callback, progress_callback):
        self.currenttask[module] = task
        gui_callback() #TODO: Use gui_callback for completion and errors as well
        taskdata = self.currenttasks[module][task]
        
        #FIXME: Currently breaks when outside of the package view and a task finishes (also needs GUI connections, and progressbar)
        
        print("TASKS DEBUG: Working on", task)
        moduletype = taskdata["type"]
        if moduletype == "item":
            if taskdata["operation"] == 0:
                self.storebrain.pkgmgmt_modules[taskdata["module"]].task_install_package(taskdata["packagename"], taskdata["source"], taskdata["subsource"], taskdata["bonuses"])
            elif taskdata["operation"] == 1:
                self.storebrain.pkgmgmt_modules[taskdata["module"]].task_update_package(taskdata["packagename"], taskdata["source"], taskdata["subsource"])
            elif taskdata["operation"] == 2:
                self.storebrain.pkgmgmt_modules[taskdata["module"]].task_remove_package(taskdata["packagename"], taskdata["source"], taskdata["subsource"])
        elif moduletype == "packageitem":
            pass
        elif moduletype == "source":
            pass
        #TODO
        
        #do_task is ran via a Thread, so we do the code in a non-threaded way.
        print("TASKS DEBUG: Finished", task)        
    


class StoreBrain():    
    #Load the initial modules
    def load_modules(self):
        MODULES_DIR = "/usr/lib/feren-storium/modules"
        
        #TODO: Make these lists be managed by gsettings or similar
        if os.path.exists(MODULES_DIR):
            for dir_name in sorted(os.listdir(MODULES_DIR+"/localpackagemgmt")):
                path = os.path.join(MODULES_DIR+"/localpackagemgmt", dir_name)
                module = None
                try:
                    module = StoreModuleContainer(self, path)
                    self.localpkgmgmt_modules[dir_name] = module.main
                except Exception as e:
                    print("Failed to load local package management module %s: \n%s\n" % (dir_name, e))
            for dir_name in sorted(os.listdir(MODULES_DIR+"/packagemgmt")):
                path = os.path.join(MODULES_DIR+"/packagemgmt", dir_name)
                module = None
                try:
                    module = StoreModuleContainer(self, path)
                    self.pkgmgmt_modules[dir_name] = module.main
                except Exception as e:
                    print("Failed to load package management module %s: \n%s\n" % (dir_name, e))
            for dir_name in sorted(os.listdir(MODULES_DIR+"/packageinfo")):
                path = os.path.join(MODULES_DIR+"/packageinfo", dir_name)
                module = None
                try:
                    module = StoreModuleContainer(self, path)
                    self.pkginfo_modules[dir_name] = module.main
                except Exception as e:
                    print("Failed to load package information module %s: \n%s\n" % (dir_name, e))
            for dir_name in sorted(os.listdir(MODULES_DIR+"/search")):
                path = os.path.join(MODULES_DIR+"/search", dir_name)
                module = None
                try:
                    module = StoreModuleContainer(self, path)
                    self.search_modules[dir_name] = module.main
                except Exception as e:
                    print("Failed to load search module %s: \n%s\n" % (dir_name, e))
            for dir_name in sorted(os.listdir(MODULES_DIR+"/sourceinfo")):
                path = os.path.join(MODULES_DIR+"/sourceinfo", dir_name)
                module = None
                try:
                    module = StoreModuleContainer(self, path)
                    self.sourceinfo_modules[dir_name] = module.main
                except Exception as e:
                    print("Failed to load source information module %s: \n%s\n" % (dir_name, e))
            for dir_name in sorted(os.listdir(MODULES_DIR+"/settings")):
                path = os.path.join(MODULES_DIR+"/settings", dir_name)
                module = None
                try:
                    module = StoreModuleContainer(self, path)
                    self.settings_modules[dir_name] = module.main
                except Exception as e:
                    print("Failed to load settings module %s: \n%s\n" % (dir_name, e))
    
    
    def __init__(self):
        self.tasks = StoreTasks()
        self.tasks.storebrain = self
        
        self.gui_module = StoreModuleContainer(self, "/usr/lib/feren-storium/modules/gui/gtk3-demo").main
        # TODO: Have it be determined by gsettings
        #self.settings_gui_module = StoreModuleContainer(self, "/usr/lib/feren-storium/modules/settings-gui/gtk3-demo").main
        # TODO: Have it be determined by gsettings
        self.localpkgmgmt_modules = {}
        self.pkgmgmt_modules = {}
        self.pkginfo_modules = {}
        self.search_modules = {}
        self.sourceinfo_modules = {}
        self.settings_modules = {}
        
        #For Search modules
        self.current_search = ""
        
        
        #For modules and GUI - mainly source selection dropdown
        self.current_package_viewed = ""
        self.current_module_selected = ""
        self.current_pkgsource_selected = ""
        self.current_pkgsubsource_selected = ""
        
        
        #Headers information for requests
        self.reqHeaders = {'user-agent': 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/94.0.4606.114 Safari/537.36'}
        
        
        self.tempdir = "/tmp/feren-storium-"+getpass.getuser()
        #Make the folder if it doesn't exist
        if not os.path.isdir(self.tempdir):
            os.mkdir(self.tempdir)
        if not os.path.isdir(self.tempdir + "/icons"):
            os.mkdir(self.tempdir + "/icons")
        
        #TODO: Remove this later on
        self.debug_module = StoreModuleContainer(self, "/usr/lib/feren-storium/modules/tempdebug").main
        
        #Name of 'generic' modules, as Store's generic modules play a big part in it
        self.generic_module = "generic"
        
        self.load_modules()
        
        # For search and whatnot
        self.refresh_overall_package_data()
                
                
    def refresh_overall_package_data(self):
        #Make the generic module make a {category: [ids]} dictionary for homepage and whatnot
        self.pkginfo_modules[self.generic_module].build_categories_ids()
        #Build each module's ID lists
        for module in self.pkginfo_modules:
            self.pkginfo_modules[module].build_ids_list()
        #TODO: Implement these into the modules and then edit the existing modules to make use of these new-added variables
        
            
        
    def item_search(self, searchterm):
        overall_results = {}
        temp_var = {}
        for module in self.search_modules:
            temp_var = self.search_modules[module].getResults(searchterm)
            temp_var = dict(temp_var) #For some reason, not doing this pops it inside the module(s) too on the next line
            temp_var.pop('status', None)
            overall_results = self.dict_recurupdate(overall_results, temp_var)
            
        return overall_results
    
    def dict_alphasort(self, d):
        sortedkeys = {}
        #Sort the search results
        for result in sorted(d.keys(), key=lambda x:x.lower()):
            sortedkeys[result] = d[result]
        return sortedkeys
    
    def dict_recurupdate(self, d, u): # I'm sure it's a recursive dictionary updater function, from what I can read of this function
        for k, v in u.items():
            if isinstance(v, collections.abc.Mapping):
                d[k] = self.dict_recurupdate(d.get(k, {}), v)
            else:
                d[k] = v
        return d
    
    
    def add_to_packageinfo(self, packageid):
        # Add package name to all packagestorages of modules that can house this package
        for module in self.pkgmgmt_modules:
            try:
                self.pkgmgmt_modules[module].pkgstorage_add(packageid)
            except:
                pass
    
    
    def get_sources(self, packagename):
        sourcesdict = {}
        #"modulename:internalname": "dropdown human readable name"
        for module in self.pkgmgmt_modules:
            sources = []
            try:
                if packagename in self.pkgmgmt_modules[module].packagestorage:
                    sources = self.pkgmgmt_modules[module].get_sources(packagename)
                    for source in sources:
                        sourcesdict[module + ":" + source] = self.sourceinfo_modules[self.generic_module].getSourceSelectName(module, source)
            except:
                pass
        return sourcesdict
    
    def get_subsources(self, sourceid, sourcetype):
        subsourcesdict = {}
        #"internalname": "dropdown human readable name"
        
        try:
            sources = self.sourceinfo_modules[self.generic_module].getSubSources(sourceid, sourcetype)
            for source in sources:
                subsourcesdict[source] = self.sourceinfo_modules[self.generic_module].getSourceSelectName(sourceid, sourcetype, source)
        except:
            subsourcesdict = {}
        return subsourcesdict
    
    
    def get_package_moduleorder(self, packagename):
        try:
            return self.pkginfo_modules[self.generic_module].getPackageJSON()[packagename]["order-of-module-importance"]
        except:
            pass
            
    
    def get_item_info(self, packagename, packagetype, mergewithgeneric=True): #TODO: Figure out what TF to do with this - it currently has packagetype be the module name instead of a source name or whatever
        if mergewithgeneric == True:
            extrainfo = self.get_generic_item_info(packagename)
        else:
            extrainfo = {}
        
        for module in self.pkginfo_modules:
            if module != self.pkginfo_modules[self.generic_module]: #If the generic module, skip
                if packagetype in self.pkginfo_modules[module].types_provided or "all" in self.pkginfo_modules[module].types_provided: #Add data from each pkginfo module that has the source
                    extrainfo = self.dict_recurupdate(extrainfo, self.pkginfo_modules[module].getInfo(packagename, packagetype))
        if extrainfo != {}:
            return extrainfo
        else:
            raise StoreBrainException(_("No information was found for %s") % packagename)
    
    def get_generic_item_info(self, packagename):
        try:
            return self.pkginfo_modules[self.generic_module].getInfo(packagename, "all") #We use 'all' as a placebo since it's not important in a generic module
        except:
            raise StoreBrainException(_("No information was found for %s") % packagename)
    
    def package_module(self, packagetype, name=False):
        #Return the first one we find's name
        for module in self.pkgmgmt_modules:
            if packagetype in self.pkgmgmt_modules[module].types_managed:
                if name:
                    return module
                else:
                    return self.pkgmgmt_modules[module]
        raise StoreBrainException(_("No package module was found for managing %s") % packagetype)
        
    def local_package_module(self, packagetype, name=False):
        #Return the first one we find's name
        for module in self.localpkgmgmt_modules:
            if packagetype in self.localpkgmgmt_modules[module].types_managed:
                if name:
                    return module
                else:
                    return self.localpkgmgmt_modules[module]
        raise StoreBrainException(_("No local package module was found for managing %s") % packagetype)
        
    def package_info_module(self, packagetype, name=False):
        #Return the first one we find's name
        for module in self.pkginfo_modules:
            if packagetype in self.pkginfo_modules[module].types_provided:
                if name:
                    return module
                else:
                    return self.pkginfo_modules[module]
        raise StoreBrainException(_("No package info module was found for %s") % packagetype)
        
    def source_info_module(self, sourcetype, name=False):
        #Return the first one we find's name
        for module in self.sourceinfo_modules:
            if sourcetype in self.sourceinfo_modules[module].types_provided:
                if name:
                    return module
                else:
                    return self.sourceinfo_modules[module]
        for module in self.sourceinfo_modules: #TODO: Figure out how to combine outputs
            if "all" in self.sourceinfo_modules[module].types_provided:
                if name:
                    return module
                else:
                    return self.sourceinfo_modules[module]
        raise StoreBrainException(_("No source info module was found for %s") % sourcetype)
    
    
    
    def set_progress(self, packagename, packagetype, value): #TODO: Change into being part of Tasks management
        self.gui_module.set_progress(packagename, packagetype, value)
        
        
    def get_icon(self, iconuri, packagename): #TODO: Move icons from /tmp to ~/.cache, and set a disk space cap on it
        if not iconuri.startswith("file://"):
            try:
                #Download the application icon
                if not os.path.isfile(self.tempdir+"/icons/"+packagename):
                    r=requests.get(iconuri, headers=self.reqHeaders)
                    with open(self.tempdir+"/icons/"+packagename, "wb") as f:
                        f.write(r.content)
                
                return self.tempdir+"/icons/"+packagename
            except Exception as e:
                raise StoreBrainException(_("Failed to retrieve the icon of "+packagename+" because: %s") % e)
        else:
            if os.path.isfile(iconuri.split('file://')[1]):
                return iconuri.split('file://')[1]
            else:
                raise StoreBrainException(_("Failed to retrieve the icon of "+packagename+" because: File Not Found"))
            
        
        
        
    def run_module(self, module):
        thread = Thread(target=self._run_module,
                        args=(module,))
        thread.daemon = True
        thread.start()

    def _run_module(self, module):
        GLib.idle_add(self.__run_module, module)
        
    def __run_module(self, module):
        module.init()
        
    def run(self):
        signal.signal(signal.SIGINT, signal.SIG_DFL)
        
        self.run_module(self.debug_module)
        
        self.gui_module.init() #TODO: Move this to before the other modules run so we can display a splash screen during loading
     
     

     
     
if __name__ == "__main__":
    app = StoreBrain()
    app.run()
    