#!/usr/bin/python3

############################################
# Dependencies
############################################
import sys
import os
import time #FIXME: Is this still necessary for icon downloading?
import json
from threading import Thread, Event
from functools import partial #Used to pre-supply callbacks with some/all arguments
import gettext #Translation support
import locale
import importlib #Used for module loading
import collections.abc #Required for dictMerge
import copy #Used to create clones of variables
import datetime

import requests #Grabbing files from internet


############################################
# Exceptions
############################################
class StoriumBrainException(Exception):
    pass


############################################
# API and Module Containers
############################################
#Module Container
class ModuleContainer():
    def __init__(self, path):
        sys.path.insert(0, path)
        try:
            import module
            importlib.reload(module)
            self.module = module
        except Exception as e:
            sys.path.remove(path)
            raise StoriumBrainException(e)
        sys.path.remove(path)

#Generic - single-instance API for all modules
class GenericAPI():
    def __init__(self):
        #self.getDefaultSource = Store.getDefaultSource
        pass #The functions will be mapped by Brain when initialising

#Tasks API - single-instance API for Tasks Management
class TasksAPI():
    def __init__(self):
        pass

#GUI API - single-instance API for GUI Module
class GUIAPI():
    def __init__(self):
        pass

#ItemMgmt API - instance-per-module API for item management modules
class ItemMgmtAPI():
    def __init__(self):
        pass #Functions will be mapped by Brain when initialising,
        #    however they will get their moduleid pre-filled by partial,
        #    thus multiple instances of this API are used per module.
    

############################################
# Task Storage
############################################
class TaskBody():
    def __init__(self, itemid, moduleid, operation, sourceid, subsourceid, becauseof="", depends=""):
        self.moduleid = moduleid #ID of module, e.g.: packagemgmt-apt
        self.itemid = itemid #ID of item, e.g.: mozilla-firefox
        self.operation = operation #0 for install/add, 1 for remove, 2 for update
        self.sourceid = sourceid #ID of source to obtain from
        self.subsourceid = subsourceid #ID of subsource to obtain from, if appropriate

        self.becauseof = becauseof #(optional) Task was because of - status matches said task's, and completes with that task
        self.depends = depends #(optional) Task depends on said task - if said task cancels or fails, this does too
        
        self.cancellable = True #Can be cancelled?
        self.cancelling = False #Is the task currently being cancelled?
        self.bonusids = [] #These get appended to by confirmation dialog
        
        self.progress = 0 #Progress percent


############################################
# Tasks Execution and Management
############################################
class TaskManager():
    def __init__(self, api, tasksapi):
        self.api = api
        self.tasksapi = tasksapi
        self.myTasks = {"order": {}, \
                          "pending": {}, \
                          "queue": {}, \
                          "staged": {}, \
                          "waitingforshutdown": {}}
        #Tasks order variables
        self.systemTasksOrder = {} #Stores the value given by DBus system calls
        self.tasksOrder = {} #Combined tasks order to provide to GUI

        #Tasks runner locks
        self.runningPendingRunner = False #True when iterating pending tasks
        self.runningTaskRunners = [] #Put each moduleid in this once they start (then remove once out of tasks per each moduleid)

        #Tasks management settings
        self.stageFutureTasks = False #Set to True when entering Staging Mode


    def addModuleToTasks(self, moduleid):
        if moduleid in self.myTasks["queue"]:
            return
        self.myTasks["pending"][moduleid] = []
        for i in ["queue", "staged", "waitingforshutdown"]:
            self.myTasks[i][moduleid] = {}



    def makeTask(self, itemid, moduleid, operation, sourceid, subsourceid, elevated, becauseof=None, follows=None):
        result = {}
        #Form the task's data
        # Item Information is reobtained via the module
        result["itemInfo"] = self.api.getItemInformation(itemid, moduleid, sourceid)
        result["itemid"] = itemid
        result["moduleid"] = moduleid
        result["sourceid"] = sourceid
        result["subsourceid"] = subsourceid
        # Elevated is checked for once this enters the queue
        result["elevated"] = elevated
        result["operation"] = operation
        #If given a value other than None, progress and status will mirror that of the supplied task if valid, else this task will instantly fail once targetted by the pending tasks runner
        result["becauseof"] = becauseof
        #If given a value other than None, this task will cancel if the supplied task fails or is cancelled - additionally, if that task succeeds, this task will not be cancellable
        result["follows"] = follows
        #TODO: Make these be added once adding to queue, instead of instantly:
        result["cancellable"] = False
        # TODO: Make cancellable always be True while in queue (always False in pending)
        # Progress (maximum is 100)
        result["progress"] = 0
        # Bonus IDs supplied by the changes dialog
        result["bonusids"] = []
        # Special value given once the task in follows has completed, preventing it from being cancelled
        #result["followsdone"] = True

        return result


    def bulkNewTask(self, itemids, moduleids, operations, sourceids, subsourceids, becauseofs, dependsons):
        #NOTE: All of them are a list, but where X is the item's, for each item in itemids, index, index X of moduleids, etc. is used for said item, so make sure they all have equal lengths! (use None in subsourceids, becauseofs and dependsons when not applicable)

        #Adds a new task group to pending, after creating tasks for each given item and assembling them into a full task group
        # Cannot be called by anything except for the changes dialog and Applications Playlist importer.

        pass #TODO




    def newTask(self, itemid, moduleid, operation, sourceid, subsourceid, elevated, becauseof=None, follows=None):
        #Creates task given information supplied, and adds it to pending, staged or queue depending on multiple factors

        #TODO: For systemd mode return the task id in response to the task creation signal that was just given.
        #Also TODO: Superuser tasks are stored in userland until confirmed in which case their task body is sent to systemd via signal, and also deleted from userland.

        #Create a task group to store the single task in
        #TODO: When confirmed, add dependencies to task group before converting task group into pinned tasks
        group = {}
        elevated = self.api.getSourceInformation(itemid, moduleid, sourceid)["elevated"]
        task = self.makeTask(itemid, moduleid, operation, sourceid, subsourceid, elevated, becauseof, follows)

        #Give task an ID
        tasktime = str(datetime.date.strftime(datetime.date.today(), "%H%M%Y%m%d"))
        rootused = "0" if elevated == False else "1"
        taskid = tasktime + ":" + rootused + ":" + itemid
        if taskid + ":" + moduleid in self.myTasks["order"]:
            #Not that this should be possible, but just in case
            raise StoriumBrainException(_("There is already a task called %s:%s:%s") % (tasktime, rootused, itemid))

        #Add task into group
        group[taskid] = task

        #Add task group to pending
        self.addModuleToTasks(moduleid)
        self.myTasks["pending"][moduleid].append(group)
        #...and link the task into the visual tasks order

        print("TEMP: ADDED TASK, PENDING IS NOW: " + str(self.myTasks["pending"][moduleid]))

        #Add task to end of merged tasks list, instead of remerging the system-user tasks order, for optimisation reasons
        self.tasksOrder[moduleid + ":" + taskid] = task #NOTE: Add task groups to tasksOrder as their individual tasks

        #Ask GUI to refresh its tasks list
        self.tasksapi.refreshTasksPage()

        #Force invalidate item status cache for this itemid
        pass #TODO: invalidateItemStatusCache

        #Ask GUI to refresh representations of the itemid of the added task
        pass #TODO: APIrefreshItemStatus

        #Execute the tasks runner of this module in a thread
        pass #TODO

        #Return the taskid so that it can be sent down to signal-sender (systemd) or have progress tracked for (single-instance)
        return taskid

        #Current plan:
        #   Add task
        #   Refresh tasks list in GUI
        #       Just add it to the end of merged order, as well?
        #       Execute the same call to GUI refreshTasksOrder calls to refresh the Tasks page inside the GUI
        #   Refresh status on item representations and page
        #   ...execute task
        #   When finished, remove task...
        #   Refresh tasks list in GUI (only ran when adding tasks, and when removing them)
        #       Just remove it from the merged order?
        #       Execute the same call to GUI refreshTasksOrder calls to refresh the Tasks page inside the GUI
        #   Refresh status on item representations and more
        #       TODO: forceRefresh on all itemids whose tasks were just removed?
        #   NOTE: Add call, that refreshTasksOrder calls at end, to Tasks API that tells GUI to refreshTasks?







    

    def add_module_to_data(self, moduleid): #Add moduleid to self.tasks sections so task information can be added between them
        if not moduleid in self.tasks["pending"].keys():
            self.tasks["pending"][moduleid] = {}
        if not moduleid in self.tasks["queue"].keys():
            self.tasks["queue"][moduleid] = {}
        if not moduleid in self.tasks["staged"].keys():
            self.tasks["staged"][moduleid] = {}
        if not moduleid in self.tasks["currenttask"].keys():
            self.tasks["currenttask"][moduleid] = ""

        if not moduleid in self.tasks_running[0]: #Pending
            self.tasks_running[0][moduleid] = False
        if not moduleid in self.tasks_running[1]: #Queued
            self.tasks_running[1][moduleid] = False

    
    def add_task(self, itemid, moduleid, operation, sourceid, subsourceid, becauseof="", dependson="", preconfirmed=False):
        #Create a Task Body for our new task
        newtask = TaskBody(itemid, moduleid, operation, sourceid, subsourceid, becauseof, dependson)
        #TODO: Give a task a progress callback, and a state-change callback

        taskname = moduleid+"/"+itemid+"/"+str(operation)+"/"+sourceid+"/"+subsourceid
        
        if preconfirmed == False:
            #Add to pending tasks
            self.tasks["pending"][moduleid][taskname] = newtask
            self.tasks["pending"]["order"][taskname] = newtask
        else:
            if self.stage_tasks == False:
                self.tasks["queue"][moduleid][taskname] = newtask
                self.tasks["queue"]["order"][taskname] = newtask
            else:
                self.tasks["staged"][moduleid][taskname] = newtask
                self.tasks["staged"]["order"][taskname] = newtask
        
        #Refresh item state in GUI to make it now be known to be in-tasks
        #TODO self.storeAPI.reloadPkgStates([moduleid], [itemid])
        
        #Trigger tasks launching in case it isn't doing tasks
        self.begin_tasks_management()
    
        
    def cancel_task(self, taskid): #Cancel task
        if taskid not in self.tasks["order"]:
            raise StoriumBrainException("The task %s could not be cancelled as it does not exist as a task. Perhaps the task finished?" % taskid)
        if self.tasks["order"][taskid].cancellable == False:
            raise StoriumBrainException("The task %s could not be cancelled." % taskid)
        self.storeAPI.cancelTask(taskid)
        
        
    def begin_tasks_management(self):
        #Launch pending tasks confirmations task if not running already
        self.begin_pending_tasks()
        #Launch main tasks runner
        self.begin_tasks()
            
        
    def begin_pending_tasks(self):
        for moduleid in self.tasks["pending"]: #Initiate tasks working for all modules
            if moduleid != "order": #Skip the 'order' variable
                thread = Thread(target=self._begin_pending_tasks,
                                args=(moduleid,))
                thread.daemon = True
                thread.start()
        
    def _begin_pending_tasks(self, moduleid):
        if self.tasks_running[0][moduleid] == True:
            return #It's already running, don't bother running it again
        
        self.tasks_running[0][moduleid] = True
        tasksdonethisloop = 1
        
        while tasksdonethisloop != 0:
            tasksdonethisloop = 0
            pendingtasks = dict(self.tasks["pending"][moduleid])

            for item in pendingtasks:
                tasksdonethisloop += 1

                #TODO: Make call to module to get package changes made
                itemsadded, itemsupdated, itemsremoved, sourcesadded, sourcesremoved = self.storeTasksAPI.getTaskChanges(pendingtasks[item])
                if pendingtasks[item].operation == 0: #Only offer bonuses during installation
                    bonusoptions = self.storeTasksAPI.getBonuses(pendingtasks[item])
                else:
                    bonusoptions = []

                response, bonusids = self.storeAPI.showTaskConfirmation(pendingtasks[item], itemsadded, itemsupdated, itemsremoved, bonusoptions)

                if response == False:
                    self.tasks["pending"][moduleid].pop(item)
                    self.tasks["pending"]["order"].pop(item)
                    continue #Skip to next loop item

                self.tasks["pending"][moduleid][item].bonusids = bonusids #Set tasks's bonuses
                if self.stage_tasks == False:
                    self.tasks["queue"][moduleid][item] = self.tasks["pending"][moduleid][item] #Clone task into queue
                    self.tasks["queue"]["order"][item] = self.tasks["pending"][moduleid][item] #Clone task into queue
                else:
                    self.tasks["staged"][moduleid][item] = self.tasks["pending"][moduleid][item] #Clone task into staged
                    self.tasks["staged"]["order"][item] = self.tasks["pending"][moduleid][item] #Clone task into queue
                self.tasks["pending"][moduleid].pop(item)
                self.tasks["pending"]["order"].pop(item)
                print("Moved %s to queue" % item)

                #Refresh item state in GUI to address the state change
                #TODO: self.storeAPI.reloadPkgStates([self.tasks["order"][item].moduleid], [self.tasks["order"][item].itemid])

                #Re-run queued tasks management in case it quit
                self.begin_tasks()
            
            
        self.tasks_running[0][moduleid] = False
        print("TASKS DEBUG ("+moduleid+"): pending tasks is all done, returning.")
            
        
    def begin_tasks(self):        
        for moduleid in self.tasks["queue"]: #Initiate tasks working for all modules
            if moduleid != "order": #Skip the 'order' variable
                thread = Thread(target=self._begin_tasks,
                                args=(moduleid,))
                thread.daemon = True
                thread.start()
        
    def _begin_tasks(self, moduleid):
        if self.tasks_running[1][moduleid] == True:
            return #It's already running, don't bother running it again

        self.tasks_running[1][moduleid] = True
        tasksdonethisloop = 1

        while tasksdonethisloop != 0:
            tasksdonethisloop = 0
            queuedtasks = dict(self.tasks["queue"][moduleid])

            for item in queuedtasks:
                if not item in self.tasks["queue"][moduleid]: #If the Task's cancelled/etc. then don't perform it
                    continue
                tasksdonethisloop += 1

                self.tasks["currenttask"][moduleid] = item #Make the task known as being the current task

                #Refresh item state in GUI to address the task starting
                #TODO: self.storeAPI.reloadPkgStates([self.tasks["order"][item].moduleid], [self.tasks["order"][item].itemid])

                print("TASKS DEBUG: " + moduleid + " is working on " + item)

                #try:
                self.storeTasksAPI.runTask(item, self.tasks["queue"][moduleid][item])
                #except Exception as exceptionstr:
                    #self.storeTasksAPI.showFailure(self.tasks["queue"][moduleid][item], exceptionstr)

                #Perform cleanup upon completion
                self.storeTasksAPI.cleanupModule(self.tasks["queue"][moduleid][item].moduleid)

                #Delete task now it's finished
                self.storeTasksAPI.deleteTask(item)

                self.tasks["currenttask"][moduleid] = "" #Clear the current task value now the task is done

                #Refresh item state in GUI to address the task completion
                #TODO: self.storeAPI.reloadPkgStates([self.tasks["order"][item].moduleid], [self.tasks["order"][item].itemid])

                print(self.tasks)


        self.tasks_running[1][moduleid] = False
        print("TASKS DEBUG ("+moduleid+"): queued tasks is all done, returning.")


    def task_progress_callback(self, progressint):
        #TODO
        pass



    def task_set_progress(self, itemid, moduleid, progressint):
        if not itemid in self.tasks["queue"][moduleid]: #Only queue tasks can have progress, not pending nor staged
            return

        self.tasks["queue"][moduleid][itemid].progress = progressint

        print(itemid + " progress is now " + str(self.tasks["queue"][moduleid][itemid].progress))

        #TODO tell gui to refresh progress


############################################
# The Brain
############################################
class StoriumBrain():

    ############################################
    # Brain initialisation
    ############################################
    def run(self):
        #signal.signal(signal.SIGINT, signal.SIG_DFL)
        pass #FIXME: Do we need that?^

    def __init__(self):
        ############################################
        # CONFIGURABLE VARIABLES
        ############################################
        #Enable translations
        gettext.install("feren-storium", "/usr/share/locale", names="ngettext")

        self.configdir = "/etc/feren-storium"
        self.usrdir = "/usr/share/feren-storium"
        self.libdir = "/usr/lib/feren-storium"
        self.userconfigdir = os.path.expanduser("~")+"/.config/feren-storium"
        self.usercachedir = os.path.expanduser("~")+"/.cache/feren-storium"
        self.debug = True #Enables additional debug output TODO: Move to Settings portion
        self.frontendname = _("Storium")
        self.frontendversion = "2023.07"
        self.requestHeaders = {'user-agent': 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/115.0.0.0 Safari/537.36'}

        ############################################
        # NON-CONFIGURABLE STUFF
        ############################################
        #Create important variables
        self.modules = {}
        self.moduleinfo = {} #Module information is cached mainly for GUI purposes
        self.modulefilewatch = {} #NOTE: Include .py modification time inside these too
        self.configs = {}
        self.guiconfigs = None
        #Storium API version (DO NOT CHANGE - USED FOR MODULE COMPATIBILITY CHECKING)
        self.apiversion = 1

        #Information requirements for module types
        self.moduleinforequirements = {"itemmgmt": ["canManageAutoUpdates", "canUpdatesRunOnShutdown"], \
            "search": [], \
            "gui": [], \
            "gui:configs": []}
        self.moduleinfoextras = {"itemmgmt": ["appsourcesFullName"], \
            "search": [], \
            "gui": [], \
            "gui:configs": []}

        #Map the Storium API
        self.initialiseAPIs()

        #Pass over to the arguments response code
        self.initialised = False #Fully loaded?
        self.respondToArguments()

    def respondToArguments(self):
        guiargs = ["--service", "tasks", "category"]
        cliargs = ["install", "reinstall", "update", "remove", "info", "warnings"]
        rootargs = ["system", "system-updates"]

        command = ""
        targetid = ""
        moduleid = ""
        sourceid = ""
        subsourceid = ""
        autoyes = False
        if len(sys.argv) != 1:
            for arg in sys.argv[1:]:
                if arg == "--yes" or arg == "-y":
                    autoyes = True
                elif arg == "--help" or arg == "-h":
                    self.showCLIHelp()
                    return #Quit after showing help
                elif arg.startswith("--subsource=") and subsourceid == "":
                    subsourceid = "".join(arg.split("=")[1:])
                elif arg.startswith("--source=") and sourceid == "":
                    sourceid = "".join(arg.split("=")[1:])
                elif arg.startswith("--module=") and moduleid == "":
                    moduleid = "".join(arg.split("=")[1:])
                elif (arg in guiargs or arg in cliargs or arg in rootargs) and command == "":
                    command = arg
                elif command == "" and (arg.startswith("/") or arg.startswith("./")):
                    command = "open"
                    targetid = arg
                    break #We have our argument, continue to initialisation
                elif command == "":
                    print(_("Unknown command %s - use --help for available options") % arg)
                    return
                elif targetid == "":
                    targetid = arg
        #Error checking
        if subsourceid != "" and sourceid == "":
            print(_("--subsource cannot be used without a source and module specified"))
            return
        elif sourceid != "" and moduleid == "":
            print(_("--source cannot be used without a module specified"))
            return
        elif (command in rootargs) and os.getuid() != 0:
            print(_("System mode is not available inside user sessions"))
            return
        elif (command in guiargs or command == "") and os.getuid() == 0:
            print(_("%s cannot be run as root") % self.frontendname)
            return

        #Launch commands in existing instance, if there is one
        if self.communicateWithStorium(command, targetid, moduleid, sourceid, subsourceid) == True:
            return #Exit here if we successfully communicated with an existing Storium

        #If not, let's initiate the appropriate frontend
        if command == "system":
            self.startSystemMode()
            return
        elif command in cliargs or command in rootargs: #system is handled above instead
            self.startCLI(command, targetid, moduleid, sourceid, subsourceid)
        else:
            self.startNormalMode(command, targetid, moduleid, sourceid, subsourceid)


    def showCLIHelp(self):
        print(_("""Usage:
  %s [OPTION...] [ID or full file path...]""") % sys.argv[0].split("/")[-1] + "\n")
        print(_("Manage packages and other items on this system or user") + "\n")
        print(_("Item Management Options:"))
        print(_("  install ITEMID - Installs ITEMID"))
        print(_("  reinstall ITEMID - Reinstalls ITEMID"))
        print(_("  update ITEMID - Updates ITEMID"))
        print(_("    update - Performs a system update"))
        print(_("  remove ITEMID - Removes ITEMID"))
        print(_("  info ITEMID - Displays information about ITEMID"))
        print(_("  warnings ITEMID - Displays warnings for ITEMID") + "\n")
        print(_("Options for Item Management Options:"))
        print(_("  --module=ID - Only search for the item in this module"))
        print(_("  --source=ID - Manage the item from this source (requires --moduleid)"))
        print(_("  --subsource=ID - Use this subsource (only works on install, requires --sourceid)"))
        #TODO: --bonuses=id1,id2
        print(_("  -y - Answer with yes on prompts") + "\n")
        print(_("Options:"))
        print(_("  category ID - Open the ID category"))
        print(_("  tasks - Open the tasks page"))
        print(_("  full file path - Opens the file if compatible"))

    def initialiseAPIs(self):
        ############################################
        # Generic API
        ############################################
        self.genericapi = GenericAPI()
        self.genericapi.enterStagingMode = self.APIenterStagingMode
        self.genericapi.getItemInformation = self.APIgetItemInformation
        self.genericapi.getItemName = self.APIgetItemName
        self.genericapi.getDefaultSource = self.APIgetDefaultSource
        self.genericapi.getSourceInformation = self.APIgetSourceInformation
        self.genericapi.getIcon = self.APIgetIcon
        self.genericapi.getImages = self.APIgetImages
        self.genericapi.isModuleAvailable = self.APIisModuleAvailable
        self.genericapi.dictMerge = self.dictMerge
        self.genericapi.getTranslation = self.getTranslation
        self.genericapi.isInitialised = self.isInitialised
        self.genericapi.configdir = self.configdir
        self.genericapi.usrdir = self.usrdir
        self.genericapi.libdir = self.libdir
        self.genericapi.userconfigdir = self.userconfigdir
        self.genericapi.usercachedir = self.usercachedir
        #TODO: Add access to getting settings
        ############################################
        # Tasks API
        ############################################
        self.tasksapi = TasksAPI()
        self.tasksapi.updateTask = self.APIupdateTask
        self.tasksapi.setTaskCancellable = self.APIsetTaskCancellable
        self.tasksapi.showItemErrorDialog = self.APIshowItemErrorDialog
        self.tasksapi.refreshTasksPage = self.APIrefreshTasksPage
        self.tasksapi.refreshItemPage = self.APIrefreshItemPage
        self.tasksapi.refreshItemStatus = self.APIrefreshItemStatus
        self.tasksapi.invalidateItemInfoCache = self.APIinvalidateItemInfoCache
        self.tasksapi.invalidateItemStatusCache = self.APIinvalidateItemStatusCache
        self.tasksapi.reinitModulesIfFileWatch = self.APIreinitModulesIfFileWatch
        ############################################
        # GUI API
        ############################################
        self.guiapi = GUIAPI()
        self.guiapi.getCustomCategories = self.APIgetCustomCategories
        self.guiapi.allItemsFilterCategory = self.APIallItemsFilterCategory
        self.guiapi.getAvailableSources = self.APIgetAvailableSources
        self.guiapi.getItemStatus = self.APTgetItemStatus
        self.guiapi.getExtraItemButtons = self.APIgetExtraItemButtons
        self.guiapi.installItemSource = self.APIinstallItemSource
        self.guiapi.installItem = self.APIinstallItem
        self.guiapi.reinstallItem = self.APIreinstallItem
        self.guiapi.updateItem = self.APIupdateItem
        self.guiapi.removeItem = self.APIremoveItem
        self.guiapi.getAvailableBonuses = self.APIgetAvailableBonuses
        self.guiapi.changeItemBonuses = self.APIchangeItemBonuses
        self.guiapi.checkForUpdates = self.APIcheckForUpdates
        #TODO: changeSetting

    def initialiseItemMgmtAPI(self, apicontainer, moduleid):
        ############################################
        # ItemMgmt API
        ############################################
        apicontainer.showGUIToast = partial(self.APIshowGUIToast, moduleid)
        apicontainer.pkgMgrWaiting = partial(self.APIpkgMgrWaiting, moduleid)
        apicontainer.getPreferSysInst = partial(self.APIgetPreferSysInst, moduleid)
        apicontainer.refreshLibraryPage = partial(self.APIrefreshLibraryPage, moduleid)


    def communicateWithStorium(self, command, targetid="", moduleid="", sourceid="", subsourceid=""):
        #Send signal to existing Store instance to power the command in certain scenarios, else return False or return False if communication fails
        print("communicateWithStorium", command, targetid, moduleid, sourceid, subsourceid)
        #Skip if Terminal-specific commands are used
        if command == "install" or command == "reinstall" or command == "update" or command == "remove" or command == "info" or command == "warnings":
            return False
        #Skip if we are root - only Terminal commands are usable
        if os.getuid() == 0:
            return False

        return False
        #TODO: Check Storium lock file exists, and if so send signal to existing Storium instance to open up GUI with commands


    def startNormalMode(self, command, targetid="", moduleid="", sourceid="", subsourceid=""):
        #Initiates Store's GUI in Normal Mode - arguments are used to know to enter a page immediately after loading
        #Load settings and GUI's settings
        self.initConfigs()
        self.initGUIConfigs()

        #Initialise GUI and show a splash screen while Storium loads
        self.initGUIModule()
        guiinit = Thread(target=self.initGUI,
                        args=(command!="--service",))
        guiinit.daemon = True
        guiinit.start()

        #Initialise modules and tasks manager, and queue initial tasks
        self.initTasksModules(False)
        self.initQueueStagedTasks() #TODO

        #Initialise search modules
        self.initSearchModules()

        #Wait until the GUI has finished initialising before continuing
        if guiinit.is_alive(): #TODO: Move all debug printing to debug call kinda like mintinstall does
            print(_("Waiting for the GUI to finish initial initialisation..."))
            guiinit.join()

        #TODO: Initialise DBus in a thread, finish GUI loading, spawn window, and then join DBus thread for rest of runtime

        #Inform GUI that the backend finished loading
        self.finishInitGUI()
        if command != "--service": #TODO: Move this to DBus signals instead
            self.spawnGUI(command, targetid, moduleid, sourceid, subsourceid)

        #TEMPORARY - will be replaced with DBus signal checking, and GUI closing response of clearing cache!
        while True:
            pass


    def startSystemMode(self):
        print("System mode Will be added in 2023.07 Beta 1!")
        return
        #Initiates Store in System Mode - no arguments as it takes signals instead
        pass #TODO


    def startCLI(self, command, targetid="", moduleid="", sourceid="", subsourceid=""):
        print("Terminal-specific commands Will be added in 2023.07 Beta 1!")
        return
        #Runs the command line interface, to perform a specific task, before exiting.

        #Check that Storium is running, first - if not, we bail out.
        #print(_("Failed to communicate with %s, exiting.") % self.frontendname)


    def initConfigs(self):
        #Use reloadConfigs to fill the values of self.configs
        try:
            self.reloadConfigs()
        except Exception as e:
            raise StoriumBrainException(_("Failed to load config files: %s") % e)

    def initGUIConfigs(self): #Split because of system mode not using it
        #Throw an exception if configs aren't yet initialised
        if self.configs == {}:
            raise StoriumBrainException(_("Configs are not yet initialised."))

        #Using the settings value for the GUI, load the GUI module's settings
        guipath = self.libdir + "/modules/" + self.configs["guipath"]
        try:
            self.guiconfigs = self.newModule(guipath, "gui", "gui:configs", self.guiapi)
        except Exception as e:
            raise StoriumBrainException(_("Failed to load GUI module %s's configs: %s") % (guipath, e))


    def initGUIModule(self): #Split because modules should never be initialised at the same time via multiple threads
        guipath = self.libdir + "/modules/" + self.configs["guipath"]
        try:
            #Initialise GUI module fully
            module, moduleinfo, filewatch = self.newModule(guipath, "gui", "gui", False, self.guiapi) #NOTE: never used in system mode
            #Add module to modules
            self.modules["gui"] = module
            #Pass through GUI's configs instance to GUI
            module.configs = self.guiconfigs
            #Add module's metadata to cache
            self.moduleinfo["gui"] = moduleinfo #FIXME: Do we need the GUI's metadata?
            #Initiate filewatches for this module
            result = {}
            for i in filewatch:
                try:
                    result[i] = os.path.getmtime(i)
                except Exception as e:
                    print(_("Failed to add %s to filewatch: %s") % (i, e))
            self.modulefilewatch["gui"] = result #FIXME: How would a GUI reinit even work? Should the GUI just... trigger a Storium relaunch?
        except Exception as e:
            raise StoriumBrainException(_("Failed to load GUI module %s: %s") % (guipath, e))

    def initGUI(self, showwindow=False):
        #Start the GUI's background operations
        self.modules["gui"].initGUI()
        #Show a splash screen while we wait if ran normally
        if showwindow == True:
            self.modules["gui"].spawnGUI("", "", "", "", "", True) #Wait is on to prevent spawnGUI running in self.spawnGUI before it has finished here


    def initTasksModules(self, systemmode):
        self.taskManager = TaskManager(self.genericapi, self.tasksapi)

        #TODO: Skip modules disabled in settings
        if os.path.exists(self.libdir+"/modules"):
            for candidateid in sorted(os.listdir(self.libdir+"/modules/itemmgmt")):
                module = None #Modules love to get reused if we don't do this.
                path = self.libdir+"/modules/itemmgmt/"+candidateid
                moduleid = "itemmgmt-"+candidateid

                #Create an instance of ItemMgmtAPI
                itemmgmtapi = ItemMgmtAPI()
                self.initialiseItemMgmtAPI(itemmgmtapi, moduleid)

                try:
                    #Initialise module
                    module, moduleinfo, filewatch = self.newModule(path, moduleid, "itemmgmt", systemmode, itemmgmtapi)
                    #Add module to modules
                    self.modules[moduleid] = module
                    #Add module's metadata to cache
                    self.moduleinfo[moduleid] = moduleinfo
                    #Initiate filewatches for this module
                    result = {}
                    for i in filewatch:
                        try:
                            result[i] = os.path.getmtime(i)
                        except Exception as e:
                            print(_("Failed to add %s to filewatch: %s") % (i, e))
                    self.modulefilewatch[moduleid] = result
                except Exception as e:
                    print(_("Failed to load item management module %s: %s") % (candidateid, e))

    def initQueueStagedTasks(self, systemmode=False):
        #Adds initial tasks to queue if there are staged tasks
        if systemmode == False:
            if os.path.isfile(self.userconfigdir + "/stagedtasks.json"):
                with open(self.userconfigdir + "/stagedtasks.json", 'r') as fp:
                    stagedtasks = json.loads(fp.read())
        else:
            stagedtasks = self.configs["stagedTasks"]

        #TODO: Add to Tasks, and then trigger beginQueueCountdown


    def initSearchModules(self):
        #TODO: Skip modules disabled in settings
        if os.path.exists(self.libdir+"/modules"):
            for candidateid in sorted(os.listdir(self.libdir+"/modules/search")):
                module = None #Modules love to get reused if we don't do this.
                path = self.libdir+"/modules/search/"+candidateid
                moduleid = "search-"+candidateid
                try:
                    #Initialise module
                    module, moduleinfo, filewatch = self.newModule(path, moduleid, "search", False, None) #NOTE: never used in system mode
                    #Add module to modules
                    self.modules[moduleid] = module
                    #Add module's metadata to cache
                    self.moduleinfo[moduleid] = moduleinfo
                    #Initiate filewatches for this module
                    result = {}
                    for i in filewatch:
                        try:
                            result[i] = os.path.getmtime(i)
                        except Exception as e:
                            print(_("Failed to add %s to filewatch: %s") % (i, e))
                    self.modulefilewatch[moduleid] = result
                except Exception as e:
                    print(_("Failed to load search module %s: %s") % (candidateid, e))


    def finishInitGUI(self):
        #Signal the GUI to finish its loading process and go past its splash screen
        self.initialised = True
        # Tell the GUI to finish loading
        self.modules["gui"].finishInitGUI()

    def spawnGUI(self, command="", targetid="", moduleid="", sourceid="", subsourceid=""):
        #Reopen GUI if closed, and go to a page in the GUI if one is given
        self.modules["gui"].spawnGUI(command, targetid, moduleid, sourceid, subsourceid) #Don't wait this time as this time acts as a window open trigger

        #TODO: Allow stripping the 'itemmgmt-' from the sourceid, and adding it back in automatically here if not present?


    def dbusSessionSignals(self):
        #Receive DBus signals to perform certain actions, and respond to certain methods, in the session bus
        pass #TODO

    def dbusSystemSignals(self):
        #Receive DBus signals to perform certain actions in the system bus
        pass #TODO
        #FIXME: this should probably be moved into a separate class or something for the system mode


    ############################################
    # Settings
    ############################################
    def reloadConfigs(self):
        #Refreshes settings from file
        result = {}
        # Get defaults
        with open(self.usrdir + "/defaults.json", 'r') as fp:
            result = json.loads(fp.read())
        # Then append custom settings
        if os.path.isfile(self.configdir + "/configs.json"):
            with open(self.configdir + "/configs.json", 'r') as fp:
                result = self.dictMerge(result, json.loads(fp.read()))

        if result == {}:
            raise StoriumBrainException(_("Config files are empty"))

        #Pass settings to Storium
        self.configs = result

        #NOTE: Should be followed up by sending a signal to all userland instances to reload their settings if this is in system mode
        #NOTE: Should be followed up by a signal to GUI to reload those settings

    def setConfig(self, settingid, value):
        #Sets a setting via Superuser, then updates the setting's value here and sends signal to superuser to reloadSettings
        #TODO: Write custom values to /etc/feren-storium/config.json
        pass #TODO


    ############################################
    # Module Initialisation
    ############################################
    def newModule(self, modulepath, moduleid, moduletype, systemmode, extraapi=None):
        #Initialise module and its information
        ############################################
        # Metadata Checks/Initialisation
        ############################################
        if not os.path.isfile(modulepath + "/metadata.json"):
            raise StoriumBrainException(_("Module does not contain information"))
        with open(modulepath + "/metadata.json", 'r') as fp:
            moduleinfo = json.loads(fp.read())
        if "APIVersion" not in moduleinfo:
            raise StoriumBrainException(_("Invalid module"))
        elif moduleinfo["APIVersion"] != self.apiversion:
            raise StoriumBrainException(_("Module is not compatible"))
        if "conditionFilesExist" in moduleinfo:
            for i in moduleinfo["conditionFilesExist"]:
                if not os.path.isfile(i):
                    #Attempt to show the dependency's name in the correct language in the exception message
                    missingitem = self.getTranslation(moduleinfo["conditionFilesExist"][i])
                    if missingitem == None:
                        #If there is no name for the dependency, we show this double-error
                        raise StoriumBrainException(_("While trying to show a dependency error, an invalid module error occurred"))
                    else:
                        raise StoriumBrainException(_("%s is not installed, but is required by this module") % missingitem)
        #Check that required values, in the current API, are present
        for i in self.moduleinforequirements[moduletype]:
            if i not in moduleinfo:
                raise StoriumBrainException(_("%s is missing from module information") % i)
        if moduletype != "gui:configs": #Might as well skip all this when initialising Settings
            if "watchFiles" in moduleinfo:
                filewatch = moduleinfo["watchFiles"]
            else:
                filewatch = []
            #Clean up remaining module information
            moduleinfo.pop("conditionFilesExist", None)
            moduleinfo.pop("watchFiles", None)
            moduleinfo.pop("APIVersion")
            for i in ["fullName", "summary"] + self.moduleinfoextras[moduletype]:
                #Only keep the locale-appropriate translation in cache
                moduleinfo[i] = self.getTranslation(moduleinfo[i])
            count = 0
            while count < len(moduleinfo["authors"]):
                moduleinfo["authors"][count]["name"] = self.getTranslation(moduleinfo["authors"][count]["name"])
                count += 1

        #Check the module has code, and that said code is valid
        if not os.path.isfile(modulepath + "/module.py"):
            raise StoriumBrainException(_("Module does not contain code"))
        with open(modulepath + "/module.py", 'r') as modulecheck:
            check = False
            for i in modulecheck:
                if i.startswith("class module(") and moduletype != "gui:configs":
                    check = True
                elif i.startswith("class settings(") and moduletype == "gui:configs":
                    check = True
            if check == False:
                raise StoriumBrainException(_("Module does not contain required class"))

        self.GUIupdateInitStatus(_("Initialising %s...") % moduleinfo["fullName"])

        ############################################
        # Module Initialisation
        ############################################
        exceptionstr = ""
        try:
            #Create a module container and initialise the module inside the container
            i = ModuleContainer(modulepath)

            if moduletype != "gui:configs":
                if extraapi == None:
                    result = i.module.module(self.genericapi, systemmode)
                else:
                    result = i.module.module(self.genericapi, extraapi, systemmode)
            else:
                result = i.module.settings()

            #Inform the module of its ID so it can use it later
            result.moduleid = moduleid
        except Exception as e:
            raise StoriumBrainException(e)

        if moduletype != "gui:configs":
            return result, moduleinfo, filewatch
        else:
            return result

    def getTranslation(self, value, getid=False):
        for i in [locale.getlocale()[0], locale.getlocale()[0].split("_")[0], "C"]:
            if i in value:
                if getid == False:
                    return value[i]
                else:
                    return i
        return None
                    
                    
    ############################################
    # API Callbacks - Generic API
    ############################################
    def APIenterStagingMode(self):
        #Check we're in systemd mode before continuing
        if True: #TODO: Add systemd mode, and a check to ensure we're in it
            return
        #Enables tasks staging in systemd mode, and sends a signal to all userland Storium instances to also enter staging mode
        pass #TODO

    def APIgetItemInformation(self, itemid, moduleid, sourceid):
        #Returns information of the supplied item
        if moduleid not in self.modules:
            raise StoriumBrainException(_("%s is not a loaded module") % moduleid)
        result = copy.deepcopy(self.modules[moduleid].getItemInformation(itemid, sourceid))
        #Use only strings appropriate to the current language
        for i in ["fullname", "summary", "description", "images", "author", "website", "bugreportsurl", "donateurl", "tosurl", "privpolurl"]:
            result[i] = self.getTranslation(result[i])
        if result["changelog"] != {}:
            for i in result["changelog"]: #Duplicated code as I don't know how to do these at once yet
                result["changelog"][i] = self.getTranslation(result["changelog"][i])
        if result["warnings"] != []:
            count = 0
            for i in result["warnings"]:
                if (count % 2) == 0:
                    count += 1
                    continue #Skip 0, 2, etc. (the translatable text is 1, 3, etc.)
                result["warnings"][count] = self.getTranslation(result["warnings"][count])
                count += 1
        return result

    def APIgetItemName(self, itemid, moduleid, sourceid):
        #Returns only the human-readable name of the supplied item
        result = copy.deepcopy(self.modules[moduleid].getItemName(itemid, sourceid))
        return self.getTranslation(result)

    def APIgetDefaultSource(self, itemid):
        #Returns the first source in GUI API's getAvailableSources
        pass #TODO

    def APIgetSourceInformation(self, itemid, moduleid, sourceid):
        #Returns information about a single source
        result = copy.deepcopy(self.modules[moduleid].getSourceInformation(itemid, sourceid))
        return result

    def APIgetIcon(self, itemid, moduleid, sourceid, iconurl):
        #Downloads the icon to cache and returns it
        #Also returns the icon in cache if it's already downloaded and not older than 4 days
        target = itemid+":"+moduleid+":"+sourceid
        cachelocat = self.getFromCache(target, "icons")
        if cachelocat != "":
            return cachelocat
        #Download the icon to the cache
        self.generateCache()
        r=requests.get(iconurl, headers=self.requestHeaders)
        with open(self.usercachedir + "/icons/" + target, "wb") as f:
            f.write(r.content)
        return self.usercachedir + "/icons/" + target

    def APIgetImages(self, folder, images):
        #Gets each image from the images dict, and puts them in the cache folder named the folder variable value
        pass #TODO

    def APIisModuleAvailable(self, moduleid):
        #If the module moduleid is currently enabled and running, return True, else return False.
        pass #TODO

    def dictMerge(self, target, writeover):
        for i in writeover.keys():
            if i in target: #Check if value exists and is a dictionary too
                if type(writeover[i]) is dict and type(target[i]) is dict:
                    #If so, recursively update the value
                    target[i] = self.dictMerge(target[i], writeover[i])
                    continue #Proceed to next key without running below code
            target[i] = writeover[i]
        return target

    def isInitialised(self):
        #Has Storium finished initialising?
        return self.initialised

    ############################################
    # Brain-only Callbacks - Generic
    ############################################
    def checkLockFile(self, lockfilelocation):
        #Checks the PID in lockfilelocation exists - if so, returns True
        #Otherwise, and if lockfilelocation does not exist, return False
        pass #TODO

    def searchItemSort(self, results):
        #Sorts results given, before removing all characters up to their first ':' and returning the sorted version of results with these changes
        pass #TODO

    def generateCache(self):
        for i in [self.usercachedir, self.usercachedir + "/icons", self.usercachedir + "/images"]:
            if not os.path.isdir(i):
                os.mkdir(i)

    def getFromCache(self, filename, folder):
        #Check cache folder exists
        if not os.path.isdir(self.usercachedir):
            return ""
        self.deleteAgedCache(self.usercachedir + "/" + folder + "/" + filename)
        if os.path.isfile(self.usercachedir + "/" + folder + "/" + filename):
            return self.usercachedir + "/" + folder + "/" + filename
        else:
            return ""

    def deleteAgedCache(self, filepath):
        if os.path.isfile(filepath):
            #Check if the file is 4+ days old
            creationtime = int(datetime.date.strftime(datetime.datetime.fromtimestamp(os.path.getmtime(filepath)), "%Y%m%d"))
            currenttime = int(datetime.date.strftime(datetime.date.today(), "%Y%m%d"))
            if currenttime-creationtime >= 4: #If so delete it
                os.remove(filepath)
        #TODO: Delete all outdated cache on Storium launch.


    ############################################
    # API Callbacks - Tasks API
    ############################################
    def APIupdateTask(self, taskid, newstatus, newprogress):
        #Sends signal to GUI to update any representations of the task taskid, and the item it is managing, to reflect a change of status and/or progress in the task.
        pass #TODO

    def APIsetTaskCancellable(self, taskid, value):
        #Sets if the task can be cancelled, and sends signal to GUI to update task representations' cancel button to reflect this change
        pass #TODO

    def APIshowItemErrorDialog(self, itemid, moduleid, sourceid, extras, errormsg):
        #Shows an error dialog, via the GUI, informing the user that the task has failed and why it failed.
        pass #TODO

    def APIrefreshTasksPage(self):
        #Tells the GUI to refresh the tasks page
        thread = Thread(target=self.modules["gui"].refreshTasksPage,
                        args=())
        thread.daemon = True
        thread.start()

    def APIrefreshItemPage(self, itemid, moduleid, sourceid):
        #Tells GUI to refresh any representations', of itemid from sourceid of moduleid
        pass #TODO

    def APIrefreshItemStatus(self, itemid, moduleid, sourceid):
        #Tells GUI to refresh the status of representations', of itemid from sourceid of moduleid
        pass #TODO

    def APIinvalidateItemInfoCache(self, moduleids=[], itemids=[]):
        #Tells modules in moduleids to delete their item information cache for items in itemids
        #Then, launches APIrefreshItemPage for each possible source
        pass #TODO

    def APIinvalidateItemStatusCache(self, moduleids=[], itemids=[], skipguirefresh=False):
        #Tells modules in moduleids to delete their item status cache for items in itemids
        #Then, tells the GUI to refresh the status shown on their representations of the affected itemids.
        pass #TODO

    def APIreinitModulesIfFileWatch(self, finishedtaskid):
        #Reinitialises modules that have file watches on files that have changed after this task

        #To reinitialise modules, call queueReinitModule(moduleid) so that the module only reinitialises once its update tasks are completed
        pass #TODO

    ############################################
    # Brain-only Callbacks - Tasks
    ############################################
    def refreshTasksOrder(self):
        #Merges superuser tasks list with userland tasks list, in chronological order, and stores it as the tasksorder variable the GUI references
        pass #TODO

    def holdUntilTasksCompleted(self):
        #Enables tasks staging, and then holds code until all tasks in all modules are complete in userland, or superuser in systemd mode, are complete.
        pass #TODO

    def runShutdownUpdates(self):
        #Moves all tasks in 'waitingforshutdown' to queue, changes Plymouth mode to Updates, and runs the queue, while removing each task from updatetasks.json as they complete.
        pass #TODO

    def beginQueueCountdown(self):
        #Waits 1 hour before automatically starting the queued tasks.
        pass #TODO

    def queueReinitModule(self, moduleid):
        #Queues module for reinitialisation once unimportant tasks are the only queued tasks left for it
        pass #TODO

    def reinitModule(self, moduleid):
        #Reinitialises a module unless there are still update or related-to-update tasks queued in which case the function instantly returns
        #If reinitialisation fails, restartStorium() is triggered.
        pass #TODO


    ############################################
    # API Callbacks - GUI API
    ############################################
    def APIgetCustomCategories(self):
        #Returns the categories each item management module wants to place items into
        result = {}
        for i in self.modules:
            if i.startswith("itemmgmt-"):
                result[i] = copy.deepcopy(self.modules[i].getCustomCategories())
        return result

    def APIallItemsFilterCategory(self, category, maximum=200, randomise=False, allCategoriesStartingWith=False):
        #Lists all items in a category, until the maximum number of items are listed.
        #  randomise: Whether to get X randomly picked items from the items listed, where X is the value of maximum
        #    NOTE: If the number of items listed is less than maximum, randomisation is disabled
        #  allCategoriesStartingWith: Queries in all categories whose IDs start with the value of category (e.g.: 'applications-' will list applications-* categories)

        #TODO: support for other arguments, and alphabetical sorting by names
        result = []
        for i in self.modules:
            if i.startswith("itemmgmt-"):
                ii = copy.deepcopy(self.modules[i].getItemsFromCategory(category))
                for item in ii:
                    if item not in result:
                        result.append(item)
        #TODO: Convert result list's structure to the one used in search, through info of their default sources, and use search sorter

        return result


    def APIgetAvailableSources(self, itemid):
        #Returns all available sources, from all modules, for this itemid
        unsorted = {} #Get non-sorted order of sources first, and segment by priority
        for i in self.modules:
            if i.startswith("itemmgmt-"):
                sources = copy.deepcopy(self.modules[i].getAvailableSources(itemid))
                for source in sources:
                    sourceid = i + "/" + source
                    #Ensure elevated value is present, to save checking later
                    if "elevated" in sources[source]:
                        elevated = sources[source]["elevated"]
                    else: #Default to False
                        elevated = False
                        sources[source]["elevated"] = elevated
                    #Ensure priority value is present
                    if "priority" in sources[source]:
                        priority = sources[source]["priority"]
                    else: #Default to 50
                        priority = 50
                        sources[source]["priority"] = priority
                    #Fix negative (invalid) priorities
                    if priority < 0:
                        priority == 0
                    #Reduce priority of redirection sources
                    if "redirectitemid" in sources[source]:
                        priority += 900
                    #Add to matching segment
                    if priority not in unsorted:
                        unsorted[priority] = {}
                    unsorted[priority][sourceid] = sources[source]
                    del unsorted[priority][sourceid]["priority"] #Redundant
        #Convert strings to their language-appropriate values
        for priority in unsorted:
            for i in unsorted[priority]:
                target = unsorted[priority][i]
                for ii in ["fullname"]:
                    target[ii] = self.getTranslation(target[ii])
                for ii in target["subsources"]:
                    target["subsources"][ii]["fullname"] = self.getTranslation(target["subsources"][ii]["fullname"])
        #If there's only 0-1 sources, return them immediately as sorting is redundant
        if len(unsorted) == 0:
            return unsorted
        elif len(unsorted) == 1:
            for i in unsorted:
                if len(unsorted[i]) <= 1:
                    return unsorted[i]
        #Sort priorities
        priorities = []
        for i in unsorted:
            priorities.append((i, unsorted[i]))
        del unsorted #No longer needed
        priorities.sort(key=self.sortFirst)
        #For each priority, sort their sources, and then merge the sources into one dict
        count = 0
        result = {}
        for priority in priorities:
            itemlist = []
            #Alphanumercalbetically sort the sources, per priority, based on their human-readable names
            for i in priority[1]:
                itemlist.append((priority[1][i]["fullname"], i))
            itemlist.sort(key=self.sortFirst)
            for i in itemlist: #Reassemble the sources, now in order, to a dict
                sourceid = i[1]
                result[sourceid] = priority[1][sourceid]
            count += 1
        del priorities
        #Return the ordered sources
        return result
    def sortFirst(self, i):
        return i[0]


    def APTgetItemStatus(self, itemid, moduleid, sourceid):
        #Returns the item's status as an ID out of the following, as well as the subsource if installed:
        # Not currently a task:
        #  0: Not installed
        #  1: Installed
        #  2: Out of date
        # Queued:
        #  3: Pending installation
        #  4: Pending reinstallation
        #  5: Pending updating
        #  6: Pending removal
        # In progress:
        #  7: Installing...
        #  8: Reinstalling...
        #  9: Updating...
        #  10: Removing...


        #TODO: Add checks for item being in tasks, and if so returning the corresponding status instead of querying its module
        return copy.deepcopy(self.modules[moduleid].getItemStatus(itemid, sourceid))


    def APIgetExtraItemButtons(self, itemid, moduleid, sourceid, status):
        #Returns extra buttons for displaying in the item details page, and installation notifications
        # Formatted as [{"text": "Test button", "tooltip": "An example button", "icon": "softwarecenter", callback: callbackHere}]

        orig = self.modules[moduleid].getExtraItemButtons(itemid, sourceid, status)
        result = []
        limit = 0
        for i in orig:
            if limit >= 2:
                break #Don't allow more than 2 buttons for sanity reasons
            a = {}
            a["text"] = copy.deepcopy(i["text"])
            a["tooltip"] = copy.deepcopy(i["tooltip"])
            a["icon"] = copy.deepcopy(i["icon"])
            a["callback"] = i["callback"]
            result.append(a)
            limit += 1
        return result


    def APIinstallItemSource(self, sourceitemid, itemid, moduleid, sourceid, subsourceid):
        #Adds the necessary source needing installing to pending, as well as adding the item itself to pending with a follows value of this task
        pass #TODO

    def APIinstallItem(self, itemid, moduleid, sourceid, subsourceid):
        #Adds the item to pending tasks to be confirmed, before starting the tasks runner if it is not currently running
        #Also runs invalidateItemStatus cache on this specific itemid.
        self.taskManager.newTask(itemid, moduleid, "install", sourceid, subsourceid, None, None)

    def APIreinstallItem(self, itemid, moduleid, sourceid, subsourceid):
        #APIinstallitem, but reinstallation instead.
        self.taskManager.newTask(itemid, moduleid, "reinstall", sourceid, subsourceid, None, None)

    def APIupdateItem(self, itemid, moduleid, sourceid, subsourceid):
        self.taskManager.newTask(itemid, moduleid, "update", sourceid, subsourceid, None, None)

    def APIremoveItem(self, itemid, moduleid, sourceid, subsourceid):
        self.taskManager.newTask(itemid, moduleid, "remove", sourceid, subsourceid, None, None)

    def APIgetAvailableBonuses(self, itemid, moduleid, sourceid, subsourceid):
        #Returns list of available bonus IDs
        pass #TODO

    def APIchangeItemBonuses(self, itemid, moduleid, sourceid, subsourceid, bonuses):
        #Ran upon user confirming changes to bonuses - initiates a new queued task with the 'changebonuses' operation, before starting the tasks runner if it is not currently running
        #Tasks for each bonus change, with becauseof values set to the resulting task as well as having matching operations, will be added
        pass #TODO

    def APIcheckForUpdates(self):
        #Gets the values of getProblemItems from all item management modules, then getUpdates, getDrivers, and getInstalled. Then, assembles them and runs reloadInstalledPage in the GUI with the IDs in those aforementioned segmented-lists, while making sure each ID only appears once.
        pass #TODO

    #TODO: put this in GUI
    #reloadInstalledPage(problemItems, updates, drivers, installed):
    #    #Reloads all the parts of the drivers/problems/updates/drivers/installed page, except for Tasks, using the lists provided in the function's arguments.

    ############################################
    # Brain-only Callbacks - GUI
    ############################################
    def getPreferSystemWideInstalls(self):
        #Returns the value of the preference according to the GUI module
        pass #TODO

    def confirmPendingItem(self, taskgroupid):
        #Shows a confirmation dialog, and returns True if the user chose to continue, else False
        pass #TODO

    def refreshSources(self, itemid):
        #Calls refreshSources in the GUI with this itemid.
        pass #TODO

    def taskProgress(self, taskid):
        #Displays the progress and status of a task in a Terminal-friendly format
        #Used in single instance mode, or when running this executable with a management argument
        pass #TODO

    def restartStore(self):
        #Runs holdUntilTasksCompleted in the Tasks API, saves staged tasks, deletes its lockfile, spawns a new Store process and then exits.
        #In systemd mode, restarts the service before exiting.
        pass #TODO

    def GUIupdateInitStatus(self, value):
        #Updates initialisation status on the GUI's splash screen, if there is one, else prints to command line
        if "gui" in self.modules:
            self.modules["gui"].updateInitStatus(value)
        if self.guiconfigs != None and self.guiconfigs.getDebugOutput() == True:
            print(_("Initialisation process: %s") % value)

    ############################################
    # API Callbacks - ItemMgmt API
    ############################################
    def APIshowGUIToast(self, moduleid, text, icon="info"):
        pass #TODO

    def APIpkgMgrWaiting(self, moduleid, value, taskid):
        pass #TODO

    def APIgetPreferSysInst(self, moduleid):
        pass #TODO

    def APIrefreshLibraryPage(self, moduleid):
        pass #TODO



############################################
# Initialise Storium API
############################################
if __name__ == "__main__":
    app = StoriumBrain()
    app.run()
