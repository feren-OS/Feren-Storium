#!/usr/bin/python3

############################################
# Dependencies
############################################
import sys
import os
import time #FIXME: Is this still necessary for icon downloading?
import json
from threading import Thread, Event
from functools import partial #Used to pre-supply callbacks with some/all arguments
import gettext #Translation support
import locale
import importlib #Used for module loading
import collections.abc #Required for dictMerge
import copy #Used to create clones of variables

import requests #Grabbing files from internet


############################################
# Exceptions
############################################
class StoriumBrainException(Exception):
    pass


############################################
# API and Module Containers
############################################

#Generic - single-instance API for all modules
class GenericAPI():
    def __init__(self):
        #self.getDefaultSource = Store.getDefaultSource
        pass #The functions will be mapped by Brain when initialising

#Tasks API - single-instance API for Tasks Management
class TasksAPI():
    def __init__(self):
        pass

#GUI API - single-instance API for GUI Module
class GUIAPI():
    def __init__(self):
        pass

#ItemMgmt API - instance-per-module API for item management modules
class ItemMgmtAPI():
    def __init__(self):
        pass #Functions will be mapped by Brain when initialising,
        #    however they will get their moduleid pre-filled by partial,
        #    thus multiple instances of this API are used per module.
    

############################################
# Task Storage
############################################
class TaskBody():
    def __init__(self, itemid, moduleid, operation, sourceid, subsourceid, becauseof="", depends=""):
        self.moduleid = moduleid #ID of module, e.g.: packagemgmt-apt
        self.itemid = itemid #ID of item, e.g.: mozilla-firefox
        self.operation = operation #0 for install/add, 1 for remove, 2 for update
        self.sourceid = sourceid #ID of source to obtain from
        self.subsourceid = subsourceid #ID of subsource to obtain from, if appropriate

        self.becauseof = becauseof #(optional) Task was because of - status matches said task's, and completes with that task
        self.depends = depends #(optional) Task depends on said task - if said task cancels or fails, this does too
        
        self.cancellable = True #Can be cancelled?
        self.cancelling = False #Is the task currently being cancelled?
        self.bonusids = [] #These get appended to by confirmation dialog
        
        self.progress = 0 #Progress percent


############################################
# Tasks Execution and Management
############################################
class TaskManager():
    def __init__(self):
        self.tasks = {"pending": {"order": {}}, "queue": {"order": {}}, "staged": {"order": {}}, "currenttask": {}} #List of Tasks, in chronological order and modules order
        #self.storeAPI = StoreGenericAPI NOTE: StoriumBrain gives it this
        #self.storeTasksAPI = StoreTasksAPI NOTE: StoriumBrain gives it this
        
        self.stage_tasks = False #Are we logging out, or is Store about to restart (if so, stage future tasks instead)
        
        #For Tasks Management
        self.tasks_running = [{}, {}] #Are tasks management calls running? [Pending, Queued]


    def newTask(self, itemid, moduleid, operation, sourceid, subsourceid, becauseof="", dependson=""):
        #Creates task given information supplied, and adds it to pending, staged or queue depending on multiple factors
        #RETURNS THE TASK'S ID
        pass #TODO

        #TODO: For systemd mode return the task id in response to the task creation signal that was just given.
        #Also TODO: Superuser tasks are stored in userland until confirmed in which case their task body is sent to systemd via signal, and also deleted from userland.













    

    def add_module_to_data(self, moduleid): #Add moduleid to self.tasks sections so task information can be added between them
        if not moduleid in self.tasks["pending"].keys():
            self.tasks["pending"][moduleid] = {}
        if not moduleid in self.tasks["queue"].keys():
            self.tasks["queue"][moduleid] = {}
        if not moduleid in self.tasks["staged"].keys():
            self.tasks["staged"][moduleid] = {}
        if not moduleid in self.tasks["currenttask"].keys():
            self.tasks["currenttask"][moduleid] = ""

        if not moduleid in self.tasks_running[0]: #Pending
            self.tasks_running[0][moduleid] = False
        if not moduleid in self.tasks_running[1]: #Queued
            self.tasks_running[1][moduleid] = False

    
    def add_task(self, itemid, moduleid, operation, sourceid, subsourceid, becauseof="", dependson="", preconfirmed=False):
        #Create a Task Body for our new task
        newtask = TaskBody(itemid, moduleid, operation, sourceid, subsourceid, becauseof, dependson)
        #TODO: Give a task a progress callback, and a state-change callback

        taskname = moduleid+":"+itemid+":"+str(operation)+":"+sourceid+":"+subsourceid
        
        if preconfirmed == False:
            #Add to pending tasks
            self.tasks["pending"][moduleid][taskname] = newtask
            self.tasks["pending"]["order"][taskname] = newtask
        else:
            if self.stage_tasks == False:
                self.tasks["queue"][moduleid][taskname] = newtask
                self.tasks["queue"]["order"][taskname] = newtask
            else:
                self.tasks["staged"][moduleid][taskname] = newtask
                self.tasks["staged"]["order"][taskname] = newtask
        
        #Refresh item state in GUI to make it now be known to be in-tasks
        #TODO self.storeAPI.reloadPkgStates([moduleid], [itemid])
        
        #Trigger tasks launching in case it isn't doing tasks
        self.begin_tasks_management()
    
        
    def cancel_task(self, taskid): #Cancel task
        if taskid not in self.tasks["order"]:
            raise StoriumBrainException("The task %s could not be cancelled as it does not exist as a task. Perhaps the task finished?" % taskid)
        if self.tasks["order"][taskid].cancellable == False:
            raise StoriumBrainException("The task %s could not be cancelled." % taskid)
        self.storeAPI.cancelTask(taskid)
        
        
    def begin_tasks_management(self):
        #Launch pending tasks confirmations task if not running already
        self.begin_pending_tasks()
        #Launch main tasks runner
        self.begin_tasks()
            
        
    def begin_pending_tasks(self):
        for moduleid in self.tasks["pending"]: #Initiate tasks working for all modules
            if moduleid != "order": #Skip the 'order' variable
                thread = Thread(target=self._begin_pending_tasks,
                                args=(moduleid,))
                thread.daemon = True
                thread.start()
        
    def _begin_pending_tasks(self, moduleid):
        if self.tasks_running[0][moduleid] == True:
            return #It's already running, don't bother running it again
        
        self.tasks_running[0][moduleid] = True
        tasksdonethisloop = 1
        
        while tasksdonethisloop != 0:
            tasksdonethisloop = 0
            pendingtasks = dict(self.tasks["pending"][moduleid])

            for item in pendingtasks:
                tasksdonethisloop += 1

                #TODO: Make call to module to get package changes made
                itemsadded, itemsupdated, itemsremoved, sourcesadded, sourcesremoved = self.storeTasksAPI.getTaskChanges(pendingtasks[item])
                if pendingtasks[item].operation == 0: #Only offer bonuses during installation
                    bonusoptions = self.storeTasksAPI.getBonuses(pendingtasks[item])
                else:
                    bonusoptions = []

                response, bonusids = self.storeAPI.showTaskConfirmation(pendingtasks[item], itemsadded, itemsupdated, itemsremoved, bonusoptions)

                if response == False:
                    self.tasks["pending"][moduleid].pop(item)
                    self.tasks["pending"]["order"].pop(item)
                    continue #Skip to next loop item

                self.tasks["pending"][moduleid][item].bonusids = bonusids #Set tasks's bonuses
                if self.stage_tasks == False:
                    self.tasks["queue"][moduleid][item] = self.tasks["pending"][moduleid][item] #Clone task into queue
                    self.tasks["queue"]["order"][item] = self.tasks["pending"][moduleid][item] #Clone task into queue
                else:
                    self.tasks["staged"][moduleid][item] = self.tasks["pending"][moduleid][item] #Clone task into staged
                    self.tasks["staged"]["order"][item] = self.tasks["pending"][moduleid][item] #Clone task into queue
                self.tasks["pending"][moduleid].pop(item)
                self.tasks["pending"]["order"].pop(item)
                print("Moved %s to queue" % item)

                #Refresh item state in GUI to address the state change
                #TODO: self.storeAPI.reloadPkgStates([self.tasks["order"][item].moduleid], [self.tasks["order"][item].itemid])

                #Re-run queued tasks management in case it quit
                self.begin_tasks()
            
            
        self.tasks_running[0][moduleid] = False
        print("TASKS DEBUG ("+moduleid+"): pending tasks is all done, returning.")
            
        
    def begin_tasks(self):        
        for moduleid in self.tasks["queue"]: #Initiate tasks working for all modules
            if moduleid != "order": #Skip the 'order' variable
                thread = Thread(target=self._begin_tasks,
                                args=(moduleid,))
                thread.daemon = True
                thread.start()
        
    def _begin_tasks(self, moduleid):
        if self.tasks_running[1][moduleid] == True:
            return #It's already running, don't bother running it again

        self.tasks_running[1][moduleid] = True
        tasksdonethisloop = 1

        while tasksdonethisloop != 0:
            tasksdonethisloop = 0
            queuedtasks = dict(self.tasks["queue"][moduleid])

            for item in queuedtasks:
                if not item in self.tasks["queue"][moduleid]: #If the Task's cancelled/etc. then don't perform it
                    continue
                tasksdonethisloop += 1

                self.tasks["currenttask"][moduleid] = item #Make the task known as being the current task

                #Refresh item state in GUI to address the task starting
                #TODO: self.storeAPI.reloadPkgStates([self.tasks["order"][item].moduleid], [self.tasks["order"][item].itemid])

                print("TASKS DEBUG: " + moduleid + " is working on " + item)

                #try:
                self.storeTasksAPI.runTask(item, self.tasks["queue"][moduleid][item])
                #except Exception as exceptionstr:
                    #self.storeTasksAPI.showFailure(self.tasks["queue"][moduleid][item], exceptionstr)

                #Perform cleanup upon completion
                self.storeTasksAPI.cleanupModule(self.tasks["queue"][moduleid][item].moduleid)

                #Delete task now it's finished
                self.storeTasksAPI.deleteTask(item)

                self.tasks["currenttask"][moduleid] = "" #Clear the current task value now the task is done

                #Refresh item state in GUI to address the task completion
                #TODO: self.storeAPI.reloadPkgStates([self.tasks["order"][item].moduleid], [self.tasks["order"][item].itemid])

                print(self.tasks)


        self.tasks_running[1][moduleid] = False
        print("TASKS DEBUG ("+moduleid+"): queued tasks is all done, returning.")


    def task_progress_callback(self, progressint):
        #TODO
        pass



    def task_set_progress(self, itemid, moduleid, progressint):
        if not itemid in self.tasks["queue"][moduleid]: #Only queue tasks can have progress, not pending nor staged
            return

        self.tasks["queue"][moduleid][itemid].progress = progressint

        print(itemid + " progress is now " + str(self.tasks["queue"][moduleid][itemid].progress))

        #TODO tell gui to refresh progress


############################################
# The Brain
############################################
class StoriumBrain():

    ############################################
    # Brain initialisation
    ############################################
    def run(self):
        #signal.signal(signal.SIGINT, signal.SIG_DFL)
        pass #FIXME: Do we need that?^

    def __init__(self):
        ############################################
        # CONFIGURABLE VARIABLES
        ############################################
        #Enable translations
        gettext.install("feren-storium", "/usr/share/locale", names="ngettext")

        self.configdir = "/etc/feren-storium"
        self.usrdir = "/usr/share/feren-storium"
        self.libdir = "/usr/lib/feren-storium"
        self.userconfigdir = os.path.expanduser("~")+"/.config/feren-storium"
        self.usercachedir = os.path.expanduser("~")+"/.cache/feren-storium"
        self.debug = True #Enables additional debug output TODO: Move to Settings portion
        self.frontendname = _("Storium")
        self.frontendversion = "2023.07"

        ############################################
        # NON-CONFIGURABLE STUFF
        ############################################
        #Create important variables
        self.modules = {}
        self.moduleinfo = {} #Module information is cached mainly for GUI purposes
        self.modulefilewatch = {} #NOTE: Include .py modification time inside these too
        self.configs = {}
        self.guiconfigs = None
        #Storium API version (DO NOT CHANGE - USED FOR MODULE COMPATIBILITY CHECKING)
        self.apiversion = 1

        #Information requirements for module types
        self.moduleinforequirements = {"itemmgmt": ["canManageAutoUpdates", "canUpdatesRunOnShutdown"], \
            "search": [], \
            "gui": [], \
            "gui:configs": []}
        self.moduleinfoextras = {"itemmgmt": ["appsourcesFullName"], \
            "search": [], \
            "gui": [], \
            "gui:configs": []}

        #Map the Storium API
        self.initialiseAPIs()

        #Pass over to the arguments response code
        self.initialised = False #Fully loaded?
        self.respondToArguments()

    def respondToArguments(self):
        guiargs = ["--service", "tasks", "category"]
        cliargs = ["install", "reinstall", "update", "remove", "info", "warnings"]
        rootargs = ["system", "system-updates"]

        command = ""
        targetid = ""
        moduleid = ""
        sourceid = ""
        subsourceid = ""
        autoyes = False
        if len(sys.argv) != 1:
            for arg in sys.argv[1:]:
                if arg == "--yes" or arg == "-y":
                    autoyes = True
                elif arg == "--help" or arg == "-h":
                    self.showCLIHelp()
                    return #Quit after showing help
                elif arg.startswith("--subsource=") and subsourceid == "":
                    subsourceid = "".join(arg.split("=")[1:])
                elif arg.startswith("--source=") and sourceid == "":
                    sourceid = "".join(arg.split("=")[1:])
                elif arg.startswith("--module=") and moduleid == "":
                    moduleid = "".join(arg.split("=")[1:])
                elif (arg in guiargs or arg in cliargs or arg in rootargs) and command == "":
                    command = arg
                elif command == "" and (arg.startswith("/") or arg.startswith("./")):
                    command = "open"
                    targetid = arg
                    break #We have our argument, continue to initialisation
                elif command == "":
                    print(_("Unknown command %s - use --help for available options") % arg)
                    return
                elif targetid == "":
                    targetid = arg
        #Error checking
        if subsourceid != "" and sourceid == "":
            print(_("--subsource cannot be used without a source and module specified"))
            return
        elif sourceid != "" and moduleid == "":
            print(_("--source cannot be used without a module specified"))
            return
        elif (command in rootargs) and os.getuid() != 0:
            print(_("System mode is not available inside user sessions"))
            return
        elif (command in guiargs or command == "") and os.getuid() == 0:
            print(_("%s cannot be run as root") % self.frontendname)
            return

        #Launch commands in existing instance, if there is one
        if self.communicateWithStorium(command, targetid, moduleid, sourceid, subsourceid) == True:
            return #Exit here if we successfully communicated with an existing Storium

        #If not, let's initiate the appropriate frontend
        if command == "system":
            self.startSystemMode()
            return
        elif command in cliargs or command in rootargs: #system is handled above instead
            self.startCLI(command, targetid, moduleid, sourceid, subsourceid)
        else:
            self.startNormalMode(command, targetid, moduleid, sourceid, subsourceid)


    def showCLIHelp(self):
        print(_("""Usage:
  %s [OPTION...] [ID or full file path...]""") % sys.argv[0].split("/")[-1] + "\n")
        print(_("Manage packages and other items on this system or user") + "\n")
        print(_("Item Management Options:"))
        print(_("  install ITEMID - Installs ITEMID"))
        print(_("  reinstall ITEMID - Reinstalls ITEMID"))
        print(_("  update ITEMID - Updates ITEMID"))
        print(_("    update - Performs a system update"))
        print(_("  remove ITEMID - Removes ITEMID"))
        print(_("  info ITEMID - Displays information about ITEMID"))
        print(_("  warnings ITEMID - Displays warnings for ITEMID") + "\n")
        print(_("Options for Item Management Options:"))
        print(_("  --module=ID - Only search for the item in this module"))
        print(_("  --source=ID - Manage the item from this source (requires --moduleid)"))
        print(_("  --subsource=ID - Use this subsource (only works on install, requires --sourceid)"))
        #TODO: --bonuses=id1,id2
        print(_("  -y - Answer with yes on prompts") + "\n")
        print(_("Options:"))
        print(_("  category ID - Open the ID category"))
        print(_("  tasks - Open the tasks page"))
        print(_("  full file path - Opens the file if compatible"))

    def initialiseAPIs(self):
        ############################################
        # Generic API
        ############################################
        self.genericapi = GenericAPI()
        self.genericapi.enterStagingMode = self.APIenterStagingMode
        self.genericapi.getItemInformation = self.APIgetItemInformation
        self.genericapi.getItemName = self.APIgetItemName
        self.genericapi.getDefaultSource = self.APIgetDefaultSource
        self.genericapi.getIcon = self.APIgetIcon
        self.genericapi.getImages = self.APIgetImages
        self.genericapi.isModuleAvailable = self.APIisModuleAvailable
        self.genericapi.dictMerge = self.dictMerge
        self.genericapi.isInitialised = self.isInitialised
        ############################################
        # Tasks API
        ############################################
        self.tasksapi = TasksAPI()
        self.tasksapi.updateTask = self.APIupdateTask
        self.tasksapi.setTaskCancellable = self.APIsetTaskCancellable
        self.tasksapi.showItemErrorDialog = self.APIshowItemErrorDialog
        self.tasksapi.refreshItemInfo = self.APIrefreshItemInfo
        self.tasksapi.invalidateItemInfoCache = self.APIinvalidateItemInfoCache
        self.tasksapi.invalidateItemStatusCache = self.APIinvalidateItemStatusCache
        self.tasksapi.reinitModulesIfFileWatch = self.APIreinitModulesIfFileWatch
        ############################################
        # GUI API
        ############################################
        self.guiapi = GUIAPI()
        self.guiapi.getAvailableSources = self.APIgetAvailableSources
        self.guiapi.installItemSource = self.APIinstallItemSource
        self.guiapi.installItem = self.APIinstallItem
        self.guiapi.reinstallItem = self.APIreinstallItem
        self.guiapi.updateItem = self.APIupdateItem
        self.guiapi.removeItem = self.APIremoveItem
        self.guiapi.getAvailableBonuses = self.APIgetAvailableBonuses
        self.guiapi.changeItemBonuses = self.APIchangeItemBonuses
        self.guiapi.checkForUpdates = self.APIcheckForUpdates
        #TODO: changeSetting

    def initialiseItemMgmtAPI(self, apicontainer, moduleid):
        ############################################
        # ItemMgmt API
        ############################################
        apicontainer.showGUIToast = partial(self.APIshowGUIToast, moduleid)
        apicontainer.pkgMgrWaiting = partial(self.APIpkgMgrWaiting, moduleid)
        apicontainer.getPreferSysInst = partial(self.APIgetPreferSysInst, moduleid)


    def communicateWithStorium(self, command, targetid="", moduleid="", sourceid="", subsourceid=""):
        #Send signal to existing Store instance to power the command in certain scenarios, else return False or return False if communication fails
        print("communicateWithStorium", command, targetid, moduleid, sourceid, subsourceid)
        #Skip if Terminal-specific commands are used
        if command == "install" or command == "reinstall" or command == "update" or command == "remove" or command == "info" or command == "warnings":
            return False
        #Skip if we are root - only Terminal commands are usable
        if os.getuid() == 0:
            return False

        return False
        #TODO: Check Storium lock file exists, and if so send signal to existing Storium instance to open up GUI with commands


    def startNormalMode(self, command, targetid="", moduleid="", sourceid="", subsourceid=""):
        #Initiates Store's GUI in Normal Mode - arguments are used to know to enter a page immediately after loading
        #Load settings and GUI's settings
        self.initConfigs()
        self.initGUIConfigs()

        #Initialise GUI and show a splash screen while Storium loads
        guiinit = Thread(target=self.initGUI,
                        args=(command!="--service",))
        guiinit.daemon = True
        guiinit.start()

        #Initialise modules and tasks manager, and queue initial tasks
        self.initTasksModules() #TODO: Add a callback argument that updates GUI's status representation on its splash screen
        self.initQueueStagedTasks()

        #Initialise search modules
        self.initSearchModules()

        #Wait until the GUI has finished initialising before continuing
        if guiinit.is_alive(): #TODO: Move all debug printing to debug call kinda like mintinstall does
            print(_("Waiting for the GUI to finish initial initialisation..."))
            guiinit.join()

        #TODO: Initialise DBus in a thread, finish GUI loading, spawn window, and then join DBus thread for rest of runtime

        #Inform GUI that the backend finished loading
        self.finishInitGUI()
        if command != "--service": #TODO: Move this to DBus signals instead
            self.spawnGUI(command, targetid, moduleid, sourceid, subsourceid)

        #TEMPORARY - will be replaced with DBus signal checking, and GUI closing response of clearing cache!
        while True:
            pass


    def startSystemMode(self):
        print("System mode Will be added in 2023.07 Beta 1!")
        return
        #Initiates Store in System Mode - no arguments as it takes signals instead
        pass #TODO


    def startCLI(self, command, targetid="", moduleid="", sourceid="", subsourceid=""):
        print("Terminal-specific commands Will be added in 2023.07 Beta 1!")
        return
        #Runs the command line interface, to perform a specific task, before exiting.

        #Check that Storium is running, first - if not, we bail out.
        #print(_("Failed to communicate with %s, exiting.") % self.frontendname)


    def initConfigs(self):
        #Use reloadConfigs to fill the values of self.configs
        try:
            self.reloadConfigs()
        except Exception as e:
            raise StoriumBrainException(_("Failed to load config files: %s") % e)

    def initGUIConfigs(self): #Split because of system mode not using it
        #Throw an exception if configs aren't yet initialised
        if self.configs == {}:
            raise StoriumBrainException(_("Configs are not yet initialised."))

        #Using the settings value for the GUI, load the GUI module's settings
        guipath = self.libdir + "/modules/" + self.configs["guipath"]
        try:
            self.guiconfigs = self.newModule(guipath, "gui", "gui:configs", self.guiapi)
        except Exception as e:
            raise StoriumBrainException(_("Failed to load GUI module %s's configs: %s") % (guipath, e))


    def initGUI(self, showwindow=False):
        #Start the GUI's background operations
        guipath = self.libdir + "/modules/" + self.configs["guipath"]
        try:
            #Initialise GUI module fully
            module, moduleinfo, filewatch = self.newModule(guipath, "gui", "gui", self.guiapi)
            #Add module to modules
            self.modules["gui"] = module
            #Pass through GUI's configs instance to GUI
            module.configs = self.guiconfigs
            #Add module's metadata to cache
            self.moduleinfo["gui"] = moduleinfo #FIXME: Do we need the GUI's metadata?
            #Initiate filewatches for this module
            result = {}
            for i in filewatch:
                try:
                    result[i] = os.path.getmtime(i)
                except Exception as e:
                    print(_("Failed to add %s to filewatch: %s") % (i, e))
            self.modulefilewatch["gui"] = result #FIXME: How would a GUI reinit even work? Should the GUI just... trigger a Storium relaunch?
        except Exception as e:
            raise StoriumBrainException(_("Failed to load GUI module %s: %s") % (guipath, e))
        #Show a splash screen while we wait if ran normally
        if showwindow == True:
            module.spawnGUI()


    def initTasksModules(self):
        self.taskManager = TaskManager()

        #TODO: Skip modules disabled in settings
        if os.path.exists(self.libdir+"/modules"):
            for candidateid in sorted(os.listdir(self.libdir+"/modules/itemmgmt")):
                module = None #Modules love to get reused if we don't do this.
                path = self.libdir+"/modules/itemmgmt/"+candidateid
                moduleid = "itemmgmt-"+candidateid

                #Create an instance of ItemMgmtAPI
                itemmgmtapi = ItemMgmtAPI()
                self.initialiseItemMgmtAPI(itemmgmtapi, moduleid)

                try:
                    #Initialise module
                    module, moduleinfo, filewatch = self.newModule(path, moduleid, "itemmgmt", itemmgmtapi)
                    #Add module to modules
                    self.modules[moduleid] = module
                    #Add module's metadata to cache
                    self.moduleinfo[moduleid] = moduleinfo
                    #Initiate filewatches for this module
                    result = {}
                    for i in filewatch:
                        try:
                            result[i] = os.path.getmtime(i)
                        except Exception as e:
                            print(_("Failed to add %s to filewatch: %s") % (i, e))
                    self.modulefilewatch[moduleid] = result
                except Exception as e:
                    print(_("Failed to load item management module %s: %s") % (candidateid, e))

    def initQueueStagedTasks(self, systemmode=False):
        #Adds initial tasks to queue if there are staged tasks
        if systemmode == False:
            if os.path.isfile(self.userconfigdir + "/stagedtasks.json"):
                with open(self.userconfigdir + "/stagedtasks.json", 'r') as fp:
                    stagedtasks = json.loads(fp.read())
        else:
            stagedtasks = self.configs["stagedTasks"]

        #TODO: Add to Tasks, and then trigger beginQueueCountdown


    def initSearchModules(self):
        #TODO: Skip modules disabled in settings
        if os.path.exists(self.libdir+"/modules"):
            for candidateid in sorted(os.listdir(self.libdir+"/modules/search")):
                module = None #Modules love to get reused if we don't do this.
                path = self.libdir+"/modules/search/"+candidateid
                moduleid = "search-"+candidateid
                try:
                    #Initialise module
                    module, moduleinfo, filewatch = self.newModule(path, moduleid, "search", None)
                    #Add module to modules
                    self.modules[moduleid] = module
                    #Add module's metadata to cache
                    self.moduleinfo[moduleid] = moduleinfo
                    #Initiate filewatches for this module
                    result = {}
                    for i in filewatch:
                        try:
                            result[i] = os.path.getmtime(i)
                        except Exception as e:
                            print(_("Failed to add %s to filewatch: %s") % (i, e))
                    self.modulefilewatch[moduleid] = result
                except Exception as e:
                    print(_("Failed to load search module %s: %s") % (candidateid, e))


    def finishInitGUI(self):
        #Signal the GUI to finish its loading process and go past its splash screen
        self.initialised = True
        # Tell the GUI to finish loading
        self.modules["gui"].finishInitGUI()

    def spawnGUI(self, command="", targetid="", moduleid="", sourceid="", subsourceid=""):
        #Reopen GUI if closed, and go to a page in the GUI if one is given
        pass #TODO


    def dbusSessionSignals(self):
        #Receive DBus signals to perform certain actions, and respond to certain methods, in the session bus
        pass #TODO

    def dbusSystemSignals(self):
        #Receive DBus signals to perform certain actions in the system bus
        pass #TODO
        #FIXME: this should probably be moved into a separate class or something for the system mode


    # def todo(self):
    #
    #     self.taskManager = TaskManager()
    #
    #     self.modules = {}
    #
    #     #Prepare the APIs and map the calls:
    #     # Generic
    #     self.genericapi = StoreGenericAPI()
    #     self.genericapi.getDefaultSource = self.APIgetDefaultSource
    #     self.genericapi.getItemInformation = self.APIgetItemInformation
    #     self.genericapi.getAvailableSources = self.APIgetAvailableSources
    #     self.genericapi.getCuratedJSON = self.APIgetCuratedJSON
    #     self.genericapi.cancelTask = self.APIcancelTask
    #     self.genericapi.getAppStatus = self.APIgetAppStatus
    #     self.genericapi.installApp = self.APIinstallApp
    #     self.genericapi.updateApp = self.APIupdateApp
    #     self.genericapi.removeApp = self.APIremoveApp
    #     self.genericapi.addSource = self.APIaddSource
    #     self.genericapi.removeSource = self.APIremoveSource
    #     self.genericapi.showTaskConfirmation = self.APIshowTaskConfirmation
    #     self.genericapi.gotoID = self.APIgotoID
    #     self.genericapi.refreshMemory = self.APIrefreshMemory
    #     self.genericapi.reloadStore = self.APIreloadStore
    #     self.genericapi.reloadPages = self.APIreloadPages
    #     self.genericapi.reloadPkgStates = self.APIreloadPkgStates
    #     self.genericapi.fullUpdate = self.APIfullUpdate
    #     self.genericapi.itemSearch = self.APIitemSearch
    #     self.genericapi.getAutoUpdateOn = self.APIgetAutoUpdateOn
    #     self.genericapi.getAutoUpdateBandwidthOn = self.APIgetAutoUpdateBandwidthOn
    #     self.genericapi.getItemIDs = self.APIgetItemIDs
    #
    #     self.genericapi.getFallbackIconLocation = self.APIgetFallbackIconLocation
    #     #self.genericapi.dictMerge = self.dictMerge
    #
    #     # Tasks
    #     self.tasksapi = StoreTasksAPI()
    #     self.tasksapi.getTaskChanges = self.APIgetTaskChanges
    #     self.tasksapi.getBonuses = self.APIgetBonuses
    #     self.tasksapi.addConfirmedTask = self.APIaddConfirmedTask
    #     self.tasksapi.deleteTask = self.APIdeleteTask
    #     self.tasksapi.runTask = self.APIrunTask
    #     self.tasksapi.showFailure = self.APIshowFailure
    #     self.tasksapi.cleanupModule = self.APIcleanupModule
    #
    #     self.taskManager.storeAPI = self.genericapi
    #     self.taskManager.storeTasksAPI = self.tasksapi #Pass the APIs Tasks uses into Tasks
    #
    #     # Settings
    #     self.settingsapi = StoreSettingsAPI()
    #     self.settingsapi.changeAutoUpdateOn = self.APIchangeAutoUpdateOn
    #     self.settingsapi.getAutoUpdateSupported = self.APIgetAutoUpdateSupported
    #     self.settingsapi.changeAutoUpdateBandwidthOn = self.APIchangeAutoUpdateBandwidthOn
    #     self.settingsapi.getAutoUpdateBandwidthSupported = self.APIgetAutoUpdateBandwidthSupported
    #     self.settingsapi.getPackageMgmtModulesInfo = self.APIgetPackageMgmtModulesInfo
    #
    #     #Load the GUI while it loads
    #     self.modules["gui"] = self.new_module("/usr/lib/feren-storium/modules/gui/gtk3-demo")
    #     # TODO: Have GUI be determined by gsettings
    #
    #
    #     #Make the folder if it doesn't exist
    #     if not os.path.isdir(self.cachedir):
    #         os.mkdir(self.cachedir)
    #     if not os.path.isdir(self.cachedir + "/icons"):
    #         os.mkdir(self.cachedir + "/icons")
    #
    #     self.modules["gui"].prepareGUI()
    #     self.post_init()
    #     self.modules["gui"].showGUIHold()


    # def post_init(self):
    #     thread = Thread(target=self._post_init,
    #                     args=())
    #     thread.daemon = True
    #     thread.start()
    #
    # def _post_init(self):
    #     #Load in the modules
    #     # TODO: Have the loaded modules be determined by gsettings
    #     self.load_modules()
    #
    #
    #     #Headers information for requests
    #     self.reqHeaders = {'user-agent': 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/94.0.4606.114 Safari/537.36'}
    #
    #
    #
    #
    #     #TODO: Use idle_add to exit the splash screen and load the pages
    #     #GLib.idle_add(self.__post_init)
    #
    #
    #
    #     self.modules["gui"].GUILoadingFinished()


    ############################################
    # Settings
    ############################################
    def reloadConfigs(self):
        #Refreshes settings from file
        result = {}
        # Get defaults
        with open(self.usrdir + "/defaults.json", 'r') as fp:
            result = json.loads(fp.read())
        # Then append custom settings
        if os.path.isfile(self.configdir + "/configs.json"):
            with open(self.configdir + "/configs.json", 'r') as fp:
                result = self.dictMerge(result, json.loads(fp.read()))

        if result == {}:
            raise StoriumBrainException(_("Config files are empty"))

        #Pass settings to Storium
        self.configs = result

        #NOTE: Should be followed up by sending a signal to all userland instances to reload their settings if this is in system mode
        #NOTE: Should be followed up by a signal to GUI to reload those settings

    def setConfig(self, settingid, value):
        #Sets a setting via Superuser, then updates the setting's value here and sends signal to superuser to reloadSettings
        #TODO: Write custom values to /etc/feren-storium/config.json
        pass #TODO


    ############################################
    # Module Initialisation
    ############################################
    def newModule(self, modulepath, moduleid, moduletype, extraapi=None):
        #Initialise module and its information
        ############################################
        # Metadata Checks/Initialisation
        ############################################
        if not os.path.isfile(modulepath + "/metadata.json"):
            raise StoriumBrainException(_("Module does not contain information"))
        with open(modulepath + "/metadata.json", 'r') as fp:
            moduleinfo = json.loads(fp.read())
        if "APIVersion" not in moduleinfo:
            raise StoriumBrainException(_("Invalid module"))
        elif moduleinfo["APIVersion"] != self.apiversion:
            raise StoriumBrainException(_("Module is not compatible"))
        if "conditionFilesExist" in moduleinfo:
            for i in moduleinfo["conditionFilesExist"]:
                if not os.path.isfile(i):
                    #Attempt to show the dependency's name in the correct language in the exception message
                    missingitem = self.getTranslation(moduleinfo["conditionFilesExist"][i])
                    if missingitem == None:
                        #If there is no name for the dependency, we show this double-error
                        raise StoriumBrainException(_("While trying to show a dependency error, an invalid module error occurred"))
                    else:
                        raise StoriumBrainException(_("%s is not installed, but is required by this module") % missingitem)
        #Check that required values, in the current API, are present
        for i in self.moduleinforequirements[moduletype]:
            if i not in moduleinfo:
                raise StoriumBrainException(_("%s is missing from module information") % i)
        if moduletype != "gui:configs": #Might as well skip all this when initialising Settings
            if "watchFiles" in moduleinfo:
                filewatch = moduleinfo["watchFiles"]
            else:
                filewatch = []
            #Clean up remaining module information
            moduleinfo.pop("conditionFilesExist", None)
            moduleinfo.pop("watchFiles", None)
            moduleinfo.pop("APIVersion")
            for i in ["fullName", "summary"] + self.moduleinfoextras[moduletype]:
                keeplang = self.getTranslation(moduleinfo[i], True)
                #Clear out unused translations from our current cache
                ii = moduleinfo[i][keeplang]
                moduleinfo[i] = ii #By replacing the value with the used translation.
            count = 0
            while count < len(moduleinfo["authors"]):
                keeplang = self.getTranslation(moduleinfo["authors"][count]["name"], True)
                #Clear out unused translations from our current cache here too
                i = moduleinfo["authors"][count]["name"][keeplang]
                moduleinfo["authors"][count]["name"] = i
                count += 1

        #Check the module has code, and that said code is valid
        if not os.path.isfile(modulepath + "/module.py"):
            raise StoriumBrainException(_("Module does not contain code"))
        with open(modulepath + "/module.py", 'r') as modulecheck:
            check = False
            for i in modulecheck:
                if i.startswith("class module(") and moduletype != "gui:configs":
                    check = True
                elif i.startswith("class settings(") and moduletype == "gui:configs":
                    check = True
            if check == False:
                raise StoriumBrainException(_("Module does not contain required class"))

        self.GUIupdateInitStatus(_("Initialising %s...") % moduleinfo["fullName"])

        ############################################
        # Module Initialisation
        ############################################
        sys.path.insert(1, modulepath)
        exceptionstr = ""
        try:
            import module
            importlib.reload(module) #Otherwise only one module will be loaded across all variables

            if moduletype != "gui:configs":
                if extraapi == None:
                    result = module.module(self.genericapi)
                else:
                    result = module.module(self.genericapi, extraapi)
                result.refresh_memory()
            else:
                result = module.settings()

            #Now give the module an ID so Storium can store it later
            # result.moduleid = modulepath.split("/")[-2] + "-" + modulepath.split("/")[-1]
            result.moduleid = moduleid
            #FIXME: Do we need the module to know its ID now?
        except Exception as e:
            exceptionstr = e

        #Now remove it from path, irregardless
        sys.path.remove(modulepath)

        if exceptionstr != "":
            raise StoriumBrainException(exceptionstr)
        else:
            if moduletype != "gui:configs":
                return result, moduleinfo, filewatch
            else:
                return result

    def getTranslation(self, value, getid=False):
        for i in [locale.getlocale()[0], locale.getlocale()[0].split("_")[0], "C"]:
            if i in value:
                if getid == False:
                    return value[i]
                else:
                    return i
        return None
                    
                    
    ############################################
    # API Callbacks - Generic API
    ############################################
    def APIenterStagingMode(self):
        #Check we're in systemd mode before continuing
        if True: #TODO: Add systemd mode, and a check to ensure we're in it
            return
        #Enables tasks staging in systemd mode, and sends a signal to all userland Storium instances to also enter staging mode
        pass #TODO

    def APIgetItemInformation(self, itemid, moduleid, sourceid):
        #Returns information of the supplied item
        pass #TODO

    def APIgetItemName(self, itemid, moduleid, sourceid):
        #Returns only the human-readable name of the supplied item
        pass #TODO

    def APIgetDefaultSource(self, itemid):
        #Returns the first source in GUI API's getAvailableSources
        pass #TODO

    def APIgetIcon(self, itemid, moduleid, sourceid, iconurl, fallbacklocation):
        #Downloads the icon to cache and returns it, and failing that checks for the icon in its fallback location and returns it
        #Also returns the icon in cache if it's already downloaded and not older than 4 days

        #Check the icon exists in our cache
            #Check the icon is not older than 4 days
            #If it is, delete it
            #Else, return the icon in cache: itemid:moduleid:sourceid.png/.svg/.whatever
        #If not, download it
        #If that fails, check fallbacklocation exists
            #If it does, return it
            #Else return ""
        pass #TODO

    def APIgetImages(self, folder, images):
        #Gets each image from the images dict, and puts them in the cache folder named the folder variable value
        pass #TODO

    def APIisModuleAvailable(self, moduleid):
        #If the module moduleid is currently enabled and running, return True, else return False.
        pass #TODO

    def dictMerge(self, target, writeover):
        for i in writeover.keys():
            if i in target: #Check if value exists and is a dictionary too
                if type(writeover[i]) is dict and type(target[i]) is dict:
                    #If so, recursively update the value
                    target[i] = self.dictMerge(target[i], writeover[i])
                    continue #Proceed to next key without running below code
            target[i] = writeover[i]
        return target

    def isInitialised(self):
        #Has Storium finished initialising?
        return self.initialised

    ############################################
    # Brain-only Callbacks - Generic
    ############################################
    def checkLockFile(self, lockfilelocation):
        #Checks the PID in lockfilelocation exists - if so, returns True
        #Otherwise, and if lockfilelocation does not exist, return False
        pass #TODO

    def searchItemSort(self, results):
        #Sorts results given, before removing all characters up to their first ':' and returning the sorted version of results with these changes
        pass #TODO


    ############################################
    # API Callbacks - Tasks API
    ############################################
    def APIupdateTask(self, taskid, newstatus, newprogress):
        #Sends signal to GUI to update any representations of the task taskid, and the item it is managing, to reflect a change of status and/or progress in the task.
        pass #TODO

    def APIsetTaskCancellable(self, taskid, value):
        #Sets if the task can be cancelled, and sends signal to GUI to update task representations' cancel button to reflect this change
        pass #TODO

    def APIshowItemErrorDialog(self, itemid, moduleid, sourceid, extras, errormsg):
        #Shows an error dialog, via the GUI, informing the user that the task has failed and why it failed.
        pass #TODO

    def APIrefreshItemInfo(self, itemid, moduleid, sourceid):
        #Tells GUI to refresh any representations', of itemid from sourceid of moduleid, package information (not the installation status)
        pass #TODO

    def APIinvalidateItemInfoCache(self, moduleids=[], itemids=[]):
        #Tells modules in moduleids to delete their item information cache for items in itemids
        #Then, launches APIrefreshItemInfo for each possible source
        pass #TODO

    def APIinvalidateItemStatusCache(self, moduleids=[], itemids=[]):
        #Tells modules in moduleids to delete their item status cache for items in itemids
        #Then, tells the GUI to refresh the status shown on their representations of the affected itemids.
        pass #TODO

    def APIreinitModulesIfFileWatch(self, finishedtaskid):
        #Reinitialises modules that have file watches on files that have changed after this task

        #To reinitialise modules, call queueReinitModule(moduleid) so that the module only reinitialises once its update tasks are completed
        pass #TODO

    ############################################
    # Brain-only Callbacks - Tasks
    ############################################
    def refreshTasksOrder(self):
        #Merges superuser tasks list with userland tasks list, in chronological order, and stores it as the tasksorder variable the GUI references
        pass #TODO

    def holdUntilTasksCompleted(self):
        #Enables tasks staging, and then holds code until all tasks in all modules are complete in userland, or superuser in systemd mode, are complete.
        pass #TODO

    def runShutdownUpdates(self):
        #Moves all tasks in 'waitingforshutdown' to queue, changes Plymouth mode to Updates, and runs the queue, while removing each task from updatetasks.json as they complete.
        pass #TODO

    def beginQueueCountdown(self):
        #Waits 1 hour before automatically starting the queued tasks.
        pass #TODO

    def queueReinitModule(self, moduleid):
        #Queues module for reinitialisation once unimportant tasks are the only queued tasks left for it
        pass #TODO

    def reinitModule(self, moduleid):
        #Reinitialises a module unless there are still update or related-to-update tasks queued in which case the function instantly returns
        #If reinitialisation fails, restartStorium() is triggered.
        pass #TODO


    ############################################
    # API Callbacks - GUI API
    ############################################
    def APIgetAvailableSources(self, itemid):
        #Returns all available sources, from all modules, for this itemid
        pass #TODO

    def APIinstallItemSource(self, sourceitemid, itemid, moduleid, sourceid, subsourceid):
        #Adds the necessary source needing installing to pending, as well as adding the item itself to pending with a follows value of this task
        pass #TODO

    def APIinstallItem(self, itemid, moduleid, sourceid, subsourceid):
        #Adds the item to pending tasks to be confirmed, before starting the tasks runner if it is not currently running
        #Also runs invalidateItemStatus cache on this specific itemid.
        pass #TODO

    def APIreinstallItem(self, itemid, moduleid, sourceid, subsourceid):
        #APIinstallitem, but reinstallation instead.
        pass #TODO

    def APIupdateItem(self, itemid, moduleid, sourceid, subsourceid):
        pass #TODO

    def APIremoveItem(self, itemid, moduleid, sourceid, subsourceid):
        pass #TODO

    def APIgetAvailableBonuses(self, itemid, moduleid, sourceid, subsourceid):
        #Returns list of available bonus IDs
        pass #TODO

    def APIchangeItemBonuses(self, itemid, moduleid, sourceid, subsourceid, bonuses):
        #Ran upon user confirming changes to bonuses - initiates a new queued task with the 'changebonuses' operation, before starting the tasks runner if it is not currently running
        #Tasks for each bonus change, with becauseof values set to the resulting task as well as having matching operations, will be added
        pass #TODO

    def APIcheckForUpdates(self):
        #Gets the values of getProblemItems from all item management modules, then getUpdates, getDrivers, and getInstalled. Then, assembles them and runs reloadInstalledPage in the GUI with the IDs in those aforementioned segmented-lists, while making sure each ID only appears once.
        pass #TODO

    #TODO: put this in GUI
    #reloadInstalledPage(problemItems, updates, drivers, installed):
    #    #Reloads all the parts of the drivers/problems/updates/drivers/installed page, except for Tasks, using the lists provided in the function's arguments.

    ############################################
    # Brain-only Callbacks - GUI
    ############################################
    def getPreferSystemWideInstalls(self):
        #Returns the value of the preference according to the GUI module
        pass #TODO

    def confirmPendingItem(self, taskgroupid):
        #Shows a confirmation dialog, and returns True if the user chose to continue, else False
        pass #TODO

    def refreshSources(self, itemid):
        #Calls refreshSources in the GUI with this itemid.
        pass #TODO

    def taskProgress(self, taskid):
        #Displays the progress and status of a task in a Terminal-friendly format
        #Used in single instance mode, or when running this executable with a management argument
        pass #TODO

    def restartStore(self):
        #Runs holdUntilTasksCompleted in the Tasks API, saves staged tasks, deletes its lockfile, spawns a new Store process and then exits.
        #In systemd mode, restarts the service before exiting.
        pass #TODO

    def GUIupdateInitStatus(self, value):
        #Updates initialisation status on the GUI's splash screen, if there is one, else prints to command line
        if "gui" in self.modules:
            self.modules["gui"].updateInitStatus(value)
        if self.guiconfigs != None and self.guiconfigs.getDebugOutput() == True:
            print(_("Initialisation process: %s") % value)

    ############################################
    # API Callbacks - ItemMgmt API
    ############################################
    def APIshowGUIToast(self, moduleid, text, icon="info"):
        pass #TODO

    def APIpkgMgrWaiting(self, moduleid, value, taskid):
        pass #TODO

    def APIgetPreferSysInst(self, moduleid):
        pass #TODO



############################################
# Initialise Storium API
############################################
if __name__ == "__main__":
    app = StoriumBrain()
    app.run()
