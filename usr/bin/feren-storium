#!/usr/bin/python3

############################################
# Dependencies
############################################
import sys
import os
import time #FIXME: Is this still necessary for icon downloading?
import json
from threading import Thread, Event
from functools import partial #Used to pre-supply callbacks with some/all arguments
import gettext #Translation support
import locale
import importlib #Used for module loading
import collections.abc #Required for dictMerge
import copy #Used to create clones of variables
import datetime

import requests #Grabbing files from internet


############################################
# Exceptions
############################################
class StoriumBrainException(Exception):
    pass


############################################
# API and Module Containers
############################################
#Module Container
class ModuleContainer():
    def __init__(self, path):
        sys.path.insert(0, path)
        try:
            import module
            importlib.reload(module)
            self.module = module
        except Exception as e:
            sys.path.remove(path)
            raise StoriumBrainException(e)
        sys.path.remove(path)

#Generic - single-instance API for all modules
class GenericAPI():
    def __init__(self):
        pass #The functions will be mapped by Brain when initialising

#Tasks API - single-instance API for Tasks Management
class TasksAPI():
    def __init__(self):
        pass

#GUI API - single-instance API for GUI Module
class GUIAPI():
    def __init__(self):
        pass

#ItemMgmt API - instance-per-module API for item management modules
class ItemMgmtAPI():
    def __init__(self):
        pass #Functions will be mapped by Brain when initialising,
        #    however they will get their moduleid pre-filled by partial,
        #    thus multiple instances of this API are used per module.
    

############################################
# Task Storage
############################################
class TaskBody():
    def __init__(self, itemid, moduleid, operation, sourceid, subsourceid, becauseof="", depends=""):
        self.moduleid = moduleid #ID of module, e.g.: packagemgmt-apt
        self.itemid = itemid #ID of item, e.g.: mozilla-firefox
        self.operation = operation #0 for install/add, 1 for remove, 2 for update
        self.sourceid = sourceid #ID of source to obtain from
        self.subsourceid = subsourceid #ID of subsource to obtain from, if appropriate

        self.becauseof = becauseof #(optional) Task was because of - status matches said task's, and completes with that task
        self.depends = depends #(optional) Task depends on said task - if said task cancels or fails, this does too
        
        self.cancellable = True #Can be cancelled?
        self.cancelling = False #Is the task currently being cancelled?
        self.bonusids = [] #These get appended to by confirmation dialog
        
        self.progress = 0 #Progress percent


############################################
# Tasks Execution and Management
############################################
class TaskManager():
    def __init__(self, api, tasksapi):
        self.api = api
        self.tasksapi = tasksapi
        self.myTasks = {"order": {}, \
                          "pending": [], \
                          "queue": {}, \
                          "staged": {}, \
                          "waitingforshutdown": {}}
        self.systemTasks = {"order": {}, \
                          "pending": [], \
                          "queue": {}, \
                          "staged": {}, \
                          "waitingforshutdown": {}} #Stores the value given by DBus system calls
        self.tasksOrder = {} #Combined tasks orders to provide to GUI

        #Tasks runner locks
        self.runningPendingTriager = False #True when iterating pending tasks
        self.runningTaskRunners = [] #Put each moduleid in this once they start (then remove once out of tasks per each moduleid)

        #Tasks management settings
        self.stageFutureTasks = False #Set to True when entering Staging Mode


    def addModuleToTasks(self, moduleid):
        if moduleid in self.myTasks["queue"]:
            return
        for i in ["queue", "staged", "waitingforshutdown"]:
            self.myTasks[i][moduleid] = {}



    def makeTask(self, itemid, moduleid, operation, sourceid, subsourceid, elevated, becauseof=None, dependson=None):
        result = {}
        #Form the task's data
        # Item/Source Information is reobtained via the module
        if sourceid == "source":
            result["info"] = self.api.getSourceInformation(moduleid, itemid)
        else:
            result["info"] = self.api.getItemInformation(itemid, moduleid, sourceid)
        result["itemid"] = itemid
        result["moduleid"] = moduleid
        result["sourceid"] = sourceid
        result["subsourceid"] = subsourceid
        # Elevated is checked for once this enters the queue
        result["elevated"] = elevated
        result["operation"] = operation
        #If given a value other than None, progress and status will mirror that of the supplied task if valid, else this task will instantly fail once targetted by the pending tasks runner
        result["becauseof"] = becauseof
        #If given a value other than None, this task will cancel if the supplied task fails or is cancelled - additionally, if that task succeeds, this task will not be cancellable
        result["dependson"] = dependson
        #TODO: Make these be added once adding to queue, instead of instantly:
        result["cancellable"] = False
        # TODO: Make cancellable always be True while in queue (always False in pending)
        # Progress (maximum is 100)
        result["progress"] = 0
        # Bonus IDs supplied by the changes dialog
        result["bonusids"] = []
        # Special value given once the task in follows has completed, preventing it from being cancelled
        #result["followsdone"] = True

        return result

    def makeSourceTask(self, sourceid, moduleid, operation):
        #If the source is mapped to an item, make a task for the item instead
        if moduleid + ":" + sourceid in self.tasksapi.sourceItemMaps:
            itemmap = self.tasksapi.sourceItemMaps[moduleid + ":" + sourceid]
            elevated = self.api.getSourceInformation(itemmap["moduleid"], itemmap["sourceid"])["elevated"]
            sourcetask = self.makeTask(itemmap["itemid"], itemmap["moduleid"], operation, itemmap["sourceid"], "", elevated, None, [])
            #TODO: Obtain and use default subsource
            taskid = self.generateTaskID(itemmap["itemid"], itemmap["moduleid"], operation, itemmap["sourceid"], elevated)
            return sourcetask, taskid
        else: #Otherwise, make a task for the source and return that
            elevated = self.api.getSourceInformation(moduleid, sourceid)["sourceElevated"]
            sourcetask = self.makeTask(sourceid, moduleid, operation, "source", "", elevated, None, [])
            taskid = self.generateTaskID(sourceid, moduleid, operation, "source", elevated)
            return sourcetask, taskid
        #NOTE: Sources don't have becauseof nor can have a follows


    def addToPending(self, taskid, taskbody):
        self.myTasks["order"][taskid] = taskbody
        #Add tasks to end of merged tasks list, instead of remerging the system-user tasks order, for optimisation reasons
        self.tasksOrder[taskid] = taskbody


    def generateTaskID(self, itemid, moduleid, operation, sourceid, elevated):
        #Generates a task ID based on given criteria
        result = moduleid + ":" + ("1" if elevated == True else "0") + ":" + operation + ":" + itemid + ":" + sourceid
        if result in self.myTasks["order"]:
            #Not that this should be possible, but just in case
            raise StoriumBrainException(_("There is already a task called %s") % result)
        return result


    def bulkNewTask(self, itemids, moduleids, operations, sourceids, subsourceids, tasksintent, sourcesintent, becauseofs, dependsons):
        #NOTE: All of them are a list, but where X is the item's, for each item in itemids, index, index X of moduleids, etc. is used for said item, so make sure they all have equal lengths! (use None in subsourceids, becauseofs and dependsons when not applicable)

        #Adds a new task group to pending, after creating tasks for each given item and assembling them into a full task group
        # Cannot be called by anything except for the changes dialog and Applications Playlist importer.

        pass #TODO



    def newTask(self, itemid, moduleid, operation, sourceid, subsourceid, tasksintent, sourcesintent, becauseof="", follows=[]):
        #Creates task given information supplied, and adds it to pending, staged or queue depending on multiple factors
        #NOTE: unlike becauseof, follows can be multiple values

        #TODO:
        #   - For 2.0, allow a module to trigger a mid-task changes dialog, such as once Major Updater has determined changes to make?
        #   - Add a timeout clause, if possible, where if dependency finding takes more than 40 seconds the pending task group is skipped over until the next loop, unless it is currently the only item in the list (which case the 40 second timeout extends by 40 more seconds until the next check, etc.)
        #   - Prevent confirmation of task groups until the source adding task(s) tasks in them follows has been completed - if not satisfied yet, skip to next group
        #   - Implement security updates section of Library
        #TODO: For systemd mode return the task id in response to the task creation signal that was just given.
        #Also TODO: Superuser tasks are stored in userland until confirmed in which case their task body is sent to systemd via signal, and also deleted from userland.

        #Create a task group for the tasks and later source dependencies
        taskgroup = {"intent": tasksintent, "tasks": {}, "sourcesintent": sourcesintent, "sourcestasks": {}}


        #   TODO: Task group intents (labels to show in confirmation dialogs)
        #       in newTask, provide two new values: taskIntent and sourcesIntent?
        #       The values being intent IDs that are then queried for full strings through the GUI Settings-instance module?
        #NOTE: When mapped to an item, the source's mapped item's source dependencies will be in sourcegroup, as well as the source, in the form of the mapped item.
        #Plan:
        #   TODO: When called for confirmation, the confirmation dialog will do getItemRequiredChanges itself assuming nothing is blocking checking currently
        #   TODO: If a required source is mapped to an item, call getItemRequiredChanges on the mapped to item to determine tasks to add to sourcegroup.

        #TODO: Move to pending tasks runner as seen on left
        #TODO: New makeSourceTask, serving as a proxy between makeTask to translate mapped sources to their items, before returning their ID and their task both
        #   TODO: Make makeTask generate and return a task ID too
        # #Create a follows tally to add required source's tasks onto
        # follows = []
        #
        # if operation == "install" and sourceid != "source":
        #     #Check the destination source is enabled
        #     sourcestatus = self.api.getSourceStatus(moduleid, sourceid)
        #     if sourcestatus == 0 or sourcestatus >= 3 or sourcestatus <= 6:
        #         #If not, add a task for it
        #         if moduleid + ":" + sourceid in self.tasksapi.sourceItemMaps:
        #             itemmap = self.tasksapi.sourceItemMaps[moduleid + ":" + sourceid]
        #             elevated = self.api.getSourceInformation(itemmap["moduleid"], itemmap["sourceid"])["elevated"]
        #             sourcetask = self.makeTask(itemmap["itemid"], itemmap["moduleid"], "install", itemmap["sourceid"], "", elevated, None, [])
        #             taskid = self.generateTaskID(itemmap["itemid"], itemmap["moduleid"], "install", itemmap["sourceid"], elevated)
        #         else:
        #             elevated = self.api.getSourceInformation(moduleid, sourceid)["sourceElevated"]
        #             sourcetask = self.makeTask(sourceid, moduleid, "install", "source", "", elevated, None, []) #NOTE: There is no becauseof
        #             #...and add to sources group
        #             # First give it an ID:
        #             taskid = self.generateTaskID(sourceid, moduleid, "install", "source", elevated)
        #         # Then add it to the sources group:
        #         sourcegroup[taskid] = sourcetask
        #         # ...and add the task to follows so it must complete before the item can be installed:
        #         follows.append(taskid)
        #
        #
        # #NOTE: 'update' is not checked for above as it'd be impossible for this item to even be updatable if its origin source isn't enabled.
        # # However, extra sources could be needed by newer versions of an item, so they're checked for during an update as well.
        # if (operation == "install" or operation == "update") and sourceid != "source":
        #     #Check any extra sources required are enabled
        #     extrasourcedeps = self.tasksapi.getItemRequiredExtraSources(itemid, moduleid, sourceid)
        #     for i in extrasourcedeps:
        #         sourcestatus = self.api.getSourceStatus(moduleid, i)
        #         if sourcestatus == 0 or sourcestatus >= 3 or sourcestatus <= 6:
        #             if moduleid + ":" + i in self.tasksapi.sourceItemMaps:
        #                 itemmap = self.tasksapi.sourceItemMaps[moduleid + ":" + i]
        #                 elevated = self.api.getSourceInformation(itemmap["moduleid"], itemmap["sourceid"])["elevated"]
        #                 sourcetask = self.makeTask(itemmap["itemid"], itemmap["moduleid"], "install", itemmap["sourceid"], "", elevated, None, [])
        #                 taskid = self.generateTaskID(itemmap["itemid"], itemmap["moduleid"], "install", itemmap["sourceid"], elevated)
        #             else:
        #                 elevated = self.api.getSourceInformation(moduleid, i)["sourceElevated"]
        #                 sourcetask = self.makeTask(i, moduleid, "install", "source", "", elevated, None, [])
        #                 #...and add each missing source to sources group
        #                 taskid = self.generateTaskID(i, moduleid, "install", "source", elevated)
        #             sourcegroup[taskid] = sourcetask
        #             follows.append(taskid)

        #Now repeat with the item itself
        elevated = self.api.getSourceInformation(moduleid, sourceid)["elevated"]
        itemtask = self.makeTask(itemid, moduleid, operation, sourceid, subsourceid, elevated, None, follows)
        taskid = self.generateTaskID(itemid, moduleid, operation, sourceid, elevated)
        taskgroup["tasks"][taskid] = itemtask

        #Add the task group to pending
        # if sourcegroup != {}:
        #     for i in sourcegroup:
        #         self.myTasks["order"][i] = sourcegroup[i]
        #         self.tasksOrder[i] = sourcegroup[i]
        self.myTasks["pending"].append(taskgroup)
        self.addToPending(taskid, itemtask)

        #Ask GUI to refresh its tasks list
        self.tasksapi.refreshTasksPage()

        #Force invalidate item status cache for this itemid
        self.tasksapi.invalidateItemStatusCache([moduleid], [itemid])

        #Ask GUI to refresh representations of the itemid of the added task
        self.tasksapi.refreshItemStatus(itemid, moduleid, sourceid)

        #Execute the tasks triager for pending tasks
        thread = Thread(target=self.pendingTasksGroupsTriager,
                        args=())
        thread.daemon = True
        thread.start()

        #Return the taskid so that it can be sent down to signal-sender (systemd) or have progress tracked for (single-instance)
        return taskid

        #Current plan:
        #   Add task
        #   Refresh tasks list in GUI
        #       Just add it to the end of merged order, as well?
        #       Execute the same call to GUI refreshTasksOrder calls to refresh the Tasks page inside the GUI
        #   Refresh status on item representations and page
        #   ...execute task
        #   When finished, remove task...
        #   Refresh tasks list in GUI (only ran when adding tasks, and when removing them)
        #       Just remove it from the merged order?
        #       Execute the same call to GUI refreshTasksOrder calls to refresh the Tasks page inside the GUI
        #   Refresh status on item representations and more
        #       TODO: forceRefresh on all itemids whose tasks were just removed?
        #   NOTE: Add call, that refreshTasksOrder calls at end, to Tasks API that tells GUI to refreshTasks?



    def pendingTasksGroupsTriager(self):
        if self.runningPendingTriager == True: #Don't run more than once at a time
            return
        self.runningPendingTriager = True

        while True:
            currentgroup = 0
            #Iterate through each task group in pending to triage accordingly
            while currentgroup < len(self.myTasks["pending"]):
                group = self.myTasks["pending"][currentgroup]

                #Check for and add source dependencies
                for task in group["tasks"]:
                    taskbody = group["tasks"][task]
                    if taskbody["operation"] != "install" and taskbody["operation"] != "update" and taskbody["operation"] != "reinstall": #Only (re)installing and updating can yield source dependencies
                        continue
                    if taskbody["sourceid"] == "source": #Sources don't have dependencies
                        continue

                    #TODO: Check if all sources exist, and if not fail the group
                    #   For mapped sources, make sure their item is available and if not fail the group

                    #Collate ALL the required sources
                    sourcedeps = self.tasksapi.getItemRequiredExtraSources(taskbody["itemid"], taskbody["moduleid"], taskbody["sourceid"])
                    sourcedeps.append(taskbody["sourceid"])

                    #Check if sources are installed
                    for dep in sourcedeps:
                        status, operation, staged = 0, None, False #TODO: getItemTaskStatus
                        if status == 0: #Not installed, and no task
                            sourcetask, taskid = self.makeSourceTask(dep, taskbody["moduleid"], "install")
                            # Add the dependency to sources group
                            if not taskid in group["sourcestasks"]:
                                group["sourcestasks"][taskid] = sourcetask
                                #Add to pending
                                self.addToPending(taskid, sourcetask)
                            # Make the dependency official
                            group["tasks"][task]["dependson"].append(taskid)
                        #TODO: Other conditions, as on left

                    #Move the host task to the bottom of order
                    self.myTasks["order"].pop(task)
                    self.tasksOrder.pop(task)
                    self.addToPending(task, taskbody)

                #Now prepare the changes dialog for sources, and then tasks
                for i in [group["sourcestasks"], group["tasks"]]:
                    for task in i:
                        if taskbody["sourceid"] != "source": #Sources don't have dependencies
                            installs, updates, removals = self.tasksapi.getItemRequiredChanges(i[task]["itemid"], i[task]["moduleid"], i[task]["sourceid"])
                            #Make tasks for the dependencies, but set to mirror the host task
                            for ii in [[installs, "install"], [updates, "update"], [removals, "remove"]]:
                                for iii in ii[0]:
                                    itemtask, taskid = self.makeTask(iii["itemid"], i[task]["moduleid"], iii[1], iii["sourceid"], None, False, task, [])
                                    #TODO: Auto-inherit 'elevated' on becauseof tasks
                                    # Add the dependency to tasks group
                                    if not taskid in i:
                                        i[taskid] = itemtask
                                    #Add to pending
                                    self.addToPending(taskid, itemtask)

                    #Refresh the visual queue
                    self.tasksapi.refreshTasksPage()

                    #And finally show the respective changes dialogs.
                    #TODO: Bonuses
                    print("TASK CONFIRMATION: " + str(i))
                    pass #TODO

                currentgroup += 1





            if len(self.myTasks["pending"]) == 0:
                #Quit the triager if there are no more tasks to triage, to save resources
                self.runningPendingTriager = False
                return
            time.sleep(10) #Otherwise take a break and then loop.





















    
        
    def cancel_task(self, taskid): #Cancel task
        if taskid not in self.tasks["order"]:
            raise StoriumBrainException("The task %s could not be cancelled as it does not exist as a task. Perhaps the task finished?" % taskid)
        if self.tasks["order"][taskid].cancellable == False:
            raise StoriumBrainException("The task %s could not be cancelled." % taskid)
        self.storeAPI.cancelTask(taskid)
        
        
    def begin_tasks_management(self):
        #Launch pending tasks confirmations task if not running already
        self.begin_pending_tasks()
        #Launch main tasks runner
        self.begin_tasks()
            
        
    def begin_pending_tasks(self):
        for moduleid in self.tasks["pending"]: #Initiate tasks working for all modules
            if moduleid != "order": #Skip the 'order' variable
                thread = Thread(target=self._begin_pending_tasks,
                                args=(moduleid,))
                thread.daemon = True
                thread.start()
        
    def _begin_pending_tasks(self, moduleid):
        if self.tasks_running[0][moduleid] == True:
            return #It's already running, don't bother running it again
        
        self.tasks_running[0][moduleid] = True
        tasksdonethisloop = 1
        
        while tasksdonethisloop != 0:
            tasksdonethisloop = 0
            pendingtasks = dict(self.tasks["pending"][moduleid])

            for item in pendingtasks:
                tasksdonethisloop += 1

                #TODO: Make call to module to get package changes made
                itemsadded, itemsupdated, itemsremoved, sourcesadded, sourcesremoved = self.storeTasksAPI.getTaskChanges(pendingtasks[item])
                if pendingtasks[item].operation == 0: #Only offer bonuses during installation
                    bonusoptions = self.storeTasksAPI.getBonuses(pendingtasks[item])
                else:
                    bonusoptions = []

                response, bonusids = self.storeAPI.showTaskConfirmation(pendingtasks[item], itemsadded, itemsupdated, itemsremoved, bonusoptions)

                if response == False:
                    self.tasks["pending"][moduleid].pop(item)
                    self.tasks["pending"]["order"].pop(item)
                    continue #Skip to next loop item

                self.tasks["pending"][moduleid][item].bonusids = bonusids #Set tasks's bonuses
                if self.stage_tasks == False:
                    self.tasks["queue"][moduleid][item] = self.tasks["pending"][moduleid][item] #Clone task into queue
                    self.tasks["queue"]["order"][item] = self.tasks["pending"][moduleid][item] #Clone task into queue
                else:
                    self.tasks["staged"][moduleid][item] = self.tasks["pending"][moduleid][item] #Clone task into staged
                    self.tasks["staged"]["order"][item] = self.tasks["pending"][moduleid][item] #Clone task into queue
                self.tasks["pending"][moduleid].pop(item)
                self.tasks["pending"]["order"].pop(item)
                print("Moved %s to queue" % item)

                #Refresh item state in GUI to address the state change
                #TODO: self.storeAPI.reloadPkgStates([self.tasks["order"][item].moduleid], [self.tasks["order"][item].itemid])

                #Re-run queued tasks management in case it quit
                self.begin_tasks()
            
            
        self.tasks_running[0][moduleid] = False
        print("TASKS DEBUG ("+moduleid+"): pending tasks is all done, returning.")
            
        
    def begin_tasks(self):        
        for moduleid in self.tasks["queue"]: #Initiate tasks working for all modules
            if moduleid != "order": #Skip the 'order' variable
                thread = Thread(target=self._begin_tasks,
                                args=(moduleid,))
                thread.daemon = True
                thread.start()
        
    def _begin_tasks(self, moduleid):
        if self.tasks_running[1][moduleid] == True:
            return #It's already running, don't bother running it again

        self.tasks_running[1][moduleid] = True
        tasksdonethisloop = 1

        while tasksdonethisloop != 0:
            tasksdonethisloop = 0
            queuedtasks = dict(self.tasks["queue"][moduleid])

            for item in queuedtasks:
                if not item in self.tasks["queue"][moduleid]: #If the Task's cancelled/etc. then don't perform it
                    continue
                tasksdonethisloop += 1

                self.tasks["currenttask"][moduleid] = item #Make the task known as being the current task

                #Refresh item state in GUI to address the task starting
                #TODO: self.storeAPI.reloadPkgStates([self.tasks["order"][item].moduleid], [self.tasks["order"][item].itemid])

                print("TASKS DEBUG: " + moduleid + " is working on " + item)

                #try:
                self.storeTasksAPI.runTask(item, self.tasks["queue"][moduleid][item])
                #except Exception as exceptionstr:
                    #self.storeTasksAPI.showFailure(self.tasks["queue"][moduleid][item], exceptionstr)

                #Perform cleanup upon completion
                self.storeTasksAPI.cleanupModule(self.tasks["queue"][moduleid][item].moduleid)

                #Delete task now it's finished
                self.storeTasksAPI.deleteTask(item)

                self.tasks["currenttask"][moduleid] = "" #Clear the current task value now the task is done

                #Refresh item state in GUI to address the task completion
                #TODO: self.storeAPI.reloadPkgStates([self.tasks["order"][item].moduleid], [self.tasks["order"][item].itemid])

                print(self.tasks)


        self.tasks_running[1][moduleid] = False
        print("TASKS DEBUG ("+moduleid+"): queued tasks is all done, returning.")


    def task_progress_callback(self, progressint):
        #TODO
        pass



    def task_set_progress(self, itemid, moduleid, progressint):
        if not itemid in self.tasks["queue"][moduleid]: #Only queue tasks can have progress, not pending nor staged
            return

        self.tasks["queue"][moduleid][itemid].progress = progressint

        print(itemid + " progress is now " + str(self.tasks["queue"][moduleid][itemid].progress))

        #TODO tell gui to refresh progress


############################################
# The Brain
############################################
class StoriumBrain():

    ############################################
    # Brain initialisation
    ############################################
    def run(self):
        #signal.signal(signal.SIGINT, signal.SIG_DFL)
        pass #FIXME: Do we need that?^

    def __init__(self):
        ############################################
        # CONFIGURABLE VARIABLES
        ############################################
        #Enable translations
        gettext.install("feren-storium", "/usr/share/locale", names="ngettext")

        self.configdir = "/etc/feren-storium"
        self.usrdir = "/usr/share/feren-storium"
        self.libdir = "/usr/lib/feren-storium"
        self.userconfigdir = os.path.expanduser("~")+"/.config/feren-storium"
        self.usercachedir = os.path.expanduser("~")+"/.cache/feren-storium"
        self.debug = True #Enables additional debug output TODO: Move to Settings portion
        self.frontendname = _("Storium")
        self.frontendversion = "2023.07"
        self.requestHeaders = {'user-agent': 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/115.0.0.0 Safari/537.36'}

        ############################################
        # NON-CONFIGURABLE STUFF
        ############################################
        #Create important variables
        self.modules = {}
        self.moduleinfo = {} #Module information is cached mainly for GUI purposes
        self.modulefilewatch = {} #NOTE: Include .py modification time inside these too
        self.configs = {}
        self.guiconfigs = None
        #Storium API version (DO NOT CHANGE - USED FOR MODULE COMPATIBILITY CHECKING)
        self.apiversion = 1

        #Information requirements for module types
        self.moduleinforequirements = {"all": ["fullname", "summary", "authors", "APIVersion"], \
            "itemmgmt": ["canManageAutoUpdates", "canUpdatesRunOnShutdown", "canManageRemoveLeftovers", "canManagePackageCleanup"], \
            "search": [], \
            "gui": [], \
            "gui:configs": []}
        self.moduleinfoextras = {"itemmgmt": ["itemsourcesFullname"], \
            "search": [], \
            "gui": [], \
            "gui:configs": []}

        #Stores current maps of sources to items
        self.sourceItemMaps = {}

        #Map the Storium API
        self.initialiseAPIs()

        #Pass over to the arguments response code
        self.initialised = False #Fully loaded?
        self.respondToArguments()

    def respondToArguments(self):
        guiargs = ["--service", "tasks", "category"]
        cliargs = ["install", "reinstall", "update", "remove", "info", "warnings"]
        rootargs = ["system", "system-updates"]

        command = ""
        targetid = ""
        moduleid = ""
        sourceid = ""
        subsourceid = ""
        autoyes = False
        if len(sys.argv) != 1:
            for arg in sys.argv[1:]:
                if arg == "--yes" or arg == "-y":
                    autoyes = True
                elif arg == "--help" or arg == "-h":
                    self.showCLIHelp()
                    return #Quit after showing help
                elif arg.startswith("--subsource=") and subsourceid == "":
                    subsourceid = "".join(arg.split("=")[1:])
                elif arg.startswith("--source=") and sourceid == "":
                    sourceid = "".join(arg.split("=")[1:])
                elif arg.startswith("--module=") and moduleid == "":
                    moduleid = "".join(arg.split("=")[1:])
                elif (arg in guiargs or arg in cliargs or arg in rootargs) and command == "":
                    command = arg
                elif command == "" and (arg.startswith("/") or arg.startswith("./")):
                    command = "open"
                    targetid = arg
                    break #We have our argument, continue to initialisation
                elif command == "":
                    print(_("Unknown command %s - use --help for available options") % arg)
                    return
                elif targetid == "":
                    targetid = arg
        #Error checking
        if subsourceid != "" and sourceid == "":
            print(_("--subsource cannot be used without a source and module specified"))
            return
        elif sourceid != "" and moduleid == "":
            print(_("--source cannot be used without a module specified"))
            return
        elif (command in rootargs) and os.getuid() != 0:
            print(_("System mode is not available inside user sessions"))
            return
        elif (command in guiargs or command == "") and os.getuid() == 0:
            print(_("%s cannot be run as root") % self.frontendname)
            return

        #Launch commands in existing instance, if there is one
        if self.communicateWithStorium(command, targetid, moduleid, sourceid, subsourceid) == True:
            return #Exit here if we successfully communicated with an existing Storium

        #If not, let's initiate the appropriate frontend
        if command == "system":
            self.startSystemMode()
            return
        elif command in cliargs or command in rootargs: #system is handled above instead
            self.startCLI(command, targetid, moduleid, sourceid, subsourceid)
        else:
            self.startNormalMode(command, targetid, moduleid, sourceid, subsourceid)


    def showCLIHelp(self):
        print(_("""Usage:
  %s [OPTION...] [ID or full file path...]""") % sys.argv[0].split("/")[-1] + "\n")
        print(_("Manage packages and other items on this system or user") + "\n")
        print(_("Item Management Options:"))
        print(_("  install ITEMID - Installs ITEMID"))
        print(_("  reinstall ITEMID - Reinstalls ITEMID"))
        print(_("  update ITEMID - Updates ITEMID"))
        print(_("    update - Performs a system update"))
        print(_("  remove ITEMID - Removes ITEMID"))
        print(_("  info ITEMID - Displays information about ITEMID"))
        print(_("  warnings ITEMID - Displays warnings for ITEMID") + "\n")
        print(_("Options for Item Management Options:"))
        print(_("  --module=ID - Only search for the item in this module"))
        print(_("  --source=ID - Manage the item from this source (requires --moduleid)"))
        print(_("  --subsource=ID - Use this subsource (only works on install, requires --sourceid)"))
        #TODO: --bonuses=id1,id2
        print(_("  -y - Answer with yes on prompts") + "\n")
        print(_("Options:"))
        print(_("  category ID - Open the ID category"))
        print(_("  tasks - Open the tasks page"))
        print(_("  full file path - Opens the file if compatible"))

    def initialiseAPIs(self):
        ############################################
        # Generic API
        ############################################
        self.genericapi = GenericAPI()
        self.genericapi.enterStagingMode = self.APIenterStagingMode
        self.genericapi.getItemInformation = self.APIgetItemInformation
        self.genericapi.getItemName = self.APIgetItemName
        self.genericapi.getIcon = self.APIgetIcon
        self.genericapi.getImages = self.APIgetImages
        self.genericapi.getSourceInformation = self.APIgetSourceInformation
        self.genericapi.isItemMappedBySource = self.APIisItemMappedBySource
        self.genericapi.getSourceStatus = self.APIgetSourceStatus
        self.genericapi.dictMerge = self.dictMerge
        self.genericapi.getTranslation = self.getTranslation
        self.genericapi.isInitialised = self.isInitialised
        self.genericapi.configdir = self.configdir
        self.genericapi.usrdir = self.usrdir
        self.genericapi.libdir = self.libdir
        self.genericapi.userconfigdir = self.userconfigdir
        self.genericapi.usercachedir = self.usercachedir
        #TODO: Add access to getting settings
        ############################################
        # Tasks API
        ############################################
        self.tasksapi = TasksAPI()
        self.tasksapi.updateTask = self.APIupdateTask
        self.tasksapi.setTaskCancellable = self.APIsetTaskCancellable
        self.tasksapi.getItemRequiredChanges = self.APIgetItemRequiredChanges
        self.tasksapi.getItemRequiredExtraSources = self.APIgetItemRequiredExtraSources
        self.tasksapi.getItemBonuses = self.APIgetItemBonuses
        self.tasksapi.showItemErrorDialog = self.APIshowItemErrorDialog
        self.tasksapi.refreshTasksPage = self.APIrefreshTasksPage
        self.tasksapi.refreshItemPage = self.APIrefreshItemPage
        self.tasksapi.refreshItemStatus = self.APIrefreshItemStatus
        self.tasksapi.refreshSourceStatus = self.APIrefreshSourceStatus
        self.tasksapi.invalidateItemInfoCache = self.APIinvalidateItemInfoCache
        self.tasksapi.invalidateItemStatusCache = self.APIinvalidateItemStatusCache
        self.tasksapi.invalidateSourceInfoCache = self.APIinvalidateSourceInfoCache
        self.tasksapi.invalidateSourceStatusCache = self.APIinvalidateSourceStatusCache
        self.tasksapi.reinitModulesIfFileWatch = self.APIreinitModulesIfFileWatch
        self.tasksapi.sourceItemMaps = self.sourceItemMaps
        ############################################
        # GUI API
        ############################################
        self.guiapi = GUIAPI()
        self.guiapi.getCustomCategories = self.APIgetCustomCategories
        self.guiapi.allItemsFilterCategory = self.APIallItemsFilterCategory
        self.guiapi.allItemsInstalledFromSource = self.APIallItemsInstalledFromSource
        self.guiapi.getAvailableSources = self.APIgetAvailableSources
        self.guiapi.getSourceExists = self.APIgetSourceExists
        self.guiapi.getItemStatus = self.APIgetItemStatus
        self.guiapi.getExtraItemButtons = self.APIgetExtraItemButtons
        self.guiapi.installItem = self.APIinstallItem
        self.guiapi.reinstallItem = self.APIreinstallItem
        self.guiapi.updateItem = self.APIupdateItem
        self.guiapi.removeItem = self.APIremoveItem
        self.guiapi.getAvailableBonuses = self.APIgetAvailableBonuses
        self.guiapi.changeItemBonuses = self.APIchangeItemBonuses
        self.guiapi.installSource = self.APIinstallSource
        self.guiapi.removeSource = self.APIremoveSource
        self.guiapi.getTasks = self.APIgetTasks
        self.guiapi.checkForUpdates = self.APIcheckForUpdates
        #TODO: changeSetting

    def initialiseItemMgmtAPI(self, apicontainer, moduleid):
        ############################################
        # ItemMgmt API
        ############################################
        apicontainer.showGUIToast = partial(self.APIshowGUIToast, moduleid)
        apicontainer.pkgMgrWaiting = partial(self.APIpkgMgrWaiting, moduleid)
        apicontainer.getPreferSysInst = partial(self.APIgetPreferSysInst, moduleid)
        apicontainer.refreshLibraryPage = partial(self.APIrefreshLibraryPage, moduleid)
        apicontainer.mapSourceToItem = partial(self.APImapSourceToItem, moduleid)
        apicontainer.unmapSourceToItem = partial(self.APIunmapSourceToItem, moduleid)


    def communicateWithStorium(self, command, targetid="", moduleid="", sourceid="", subsourceid=""):
        #Send signal to existing Store instance to power the command in certain scenarios, else return False or return False if communication fails
        print("communicateWithStorium", command, targetid, moduleid, sourceid, subsourceid)
        #Skip if Terminal-specific commands are used
        if command == "install" or command == "reinstall" or command == "update" or command == "remove" or command == "info" or command == "warnings":
            return False
        #Skip if we are root - only Terminal commands are usable
        if os.getuid() == 0:
            return False

        return False
        #TODO: Check Storium lock file exists, and if so send signal to existing Storium instance to open up GUI with commands


    def startNormalMode(self, command, targetid="", moduleid="", sourceid="", subsourceid=""):
        #Initiates Store's GUI in Normal Mode - arguments are used to know to enter a page immediately after loading
        #Load settings and GUI's settings
        self.initConfigs()
        self.initGUIConfigs()

        #Initialise GUI and show a splash screen while Storium loads
        self.initGUIModule()
        guiinit = Thread(target=self.initGUI,
                        args=(command!="--service",))
        guiinit.daemon = True
        guiinit.start()

        #Initialise modules and tasks manager, and queue initial tasks
        self.initTasksModules(False)
        self.initQueueStagedTasks() #TODO

        #Initialise search modules
        self.initSearchModules()

        #Wait until the GUI has finished initialising before continuing
        if guiinit.is_alive(): #TODO: Move all debug printing to debug call kinda like mintinstall does
            print(_("Waiting for the GUI to finish initial initialisation..."))
            guiinit.join()

        #TODO: Initialise DBus in a thread, finish GUI loading, spawn window, and then join DBus thread for rest of runtime

        #Inform GUI that the backend finished loading
        self.finishInitGUI()
        if command != "--service": #TODO: Move this to DBus signals instead
            self.spawnGUI(command, targetid, moduleid, sourceid, subsourceid)

        #TEMPORARY - will be replaced with DBus signal checking, and GUI closing response of clearing cache!
        while True:
            pass


    def startSystemMode(self):
        print("System mode Will be added in 2023.07 Beta 1!")
        return
        #Initiates Store in System Mode - no arguments as it takes signals instead
        pass #TODO


    def startCLI(self, command, targetid="", moduleid="", sourceid="", subsourceid=""):
        print("Terminal-specific commands Will be added in 2023.07 Beta 1!")
        return
        #Runs the command line interface, to perform a specific task, before exiting.

        #Check that Storium is running, first - if not, we bail out.
        #print(_("Failed to communicate with %s, exiting.") % self.frontendname)


    def initConfigs(self):
        #Use reloadConfigs to fill the values of self.configs
        try:
            self.reloadConfigs()
        except Exception as e:
            raise StoriumBrainException(_("Failed to load config files: %s") % e)

    def initGUIConfigs(self): #Split because of system mode not using it
        #Throw an exception if configs aren't yet initialised
        if self.configs == {}:
            raise StoriumBrainException(_("Configs are not yet initialised."))

        #Using the settings value for the GUI, load the GUI module's settings
        guipath = self.libdir + "/modules/" + self.configs["guipath"]
        try:
            self.guiconfigs = self.newModule(guipath, "gui", "gui:configs", self.guiapi)
        except Exception as e:
            raise StoriumBrainException(_("Failed to load GUI module %s's configs: %s") % (guipath, e))


    def initGUIModule(self): #Split because modules should never be initialised at the same time via multiple threads
        guipath = self.libdir + "/modules/" + self.configs["guipath"]
        try:
            #Initialise GUI module fully
            module, moduleinfo, filewatch = self.newModule(guipath, "gui", "gui", False, self.guiapi) #NOTE: never used in system mode
            #Add module to modules
            self.modules["gui"] = module
            #Pass through GUI's configs instance to GUI
            module.configs = self.guiconfigs
            #Add module's metadata to cache
            self.moduleinfo["gui"] = moduleinfo #FIXME: Do we need the GUI's metadata?
            #Initiate filewatches for this module
            result = {}
            for i in filewatch:
                try:
                    result[i] = os.path.getmtime(i)
                except Exception as e:
                    print(_("Failed to add %s to filewatch: %s") % (i, e))
            self.modulefilewatch["gui"] = result #FIXME: How would a GUI reinit even work? Should the GUI just... trigger a Storium relaunch?
        except Exception as e:
            raise StoriumBrainException(_("Failed to load GUI module %s: %s") % (guipath, e))

    def initGUI(self, showwindow=False):
        #Start the GUI's background operations
        self.modules["gui"].initGUI()
        #Show a splash screen while we wait if ran normally
        if showwindow == True:
            self.modules["gui"].spawnGUI("", "", "", "", "", True) #Wait is on to prevent spawnGUI running in self.spawnGUI before it has finished here


    def initTasksModules(self, systemmode):
        self.taskManager = TaskManager(self.genericapi, self.tasksapi)

        #TODO: Skip modules disabled in settings
        if os.path.exists(self.libdir+"/modules"):
            for candidateid in sorted(os.listdir(self.libdir+"/modules/itemmgmt")):
                module = None #Modules love to get reused if we don't do this.
                path = self.libdir+"/modules/itemmgmt/"+candidateid
                moduleid = "itemmgmt-"+candidateid

                #Create an instance of ItemMgmtAPI
                itemmgmtapi = ItemMgmtAPI()
                self.initialiseItemMgmtAPI(itemmgmtapi, moduleid)

                try:
                    #Initialise module
                    module, moduleinfo, filewatch = self.newModule(path, moduleid, "itemmgmt", systemmode, itemmgmtapi)
                    #Add module to modules
                    self.modules[moduleid] = module
                    #Add module's metadata to cache
                    self.moduleinfo[moduleid] = moduleinfo
                    #Initiate filewatches for this module
                    result = {}
                    #Add tasks lists for this module
                    self.taskManager.addModuleToTasks(moduleid)
                    for i in filewatch:
                        try:
                            result[i] = os.path.getmtime(i)
                        except Exception as e:
                            print(_("Failed to add %s to filewatch: %s") % (i, e))
                    self.modulefilewatch[moduleid] = result
                except Exception as e:
                    print(_("Failed to load item management module %s: %s") % (candidateid, e))

    def initQueueStagedTasks(self, systemmode=False):
        #Adds initial tasks to queue if there are staged tasks
        if systemmode == False:
            if os.path.isfile(self.userconfigdir + "/stagedtasks.json"):
                with open(self.userconfigdir + "/stagedtasks.json", 'r') as fp:
                    stagedtasks = json.loads(fp.read())
        else:
            stagedtasks = self.configs["stagedTasks"]

        #TODO: Add to Tasks, and then trigger beginQueueCountdown


    def initSearchModules(self):
        #TODO: Skip modules disabled in settings
        if os.path.exists(self.libdir+"/modules"):
            for candidateid in sorted(os.listdir(self.libdir+"/modules/search")):
                module = None #Modules love to get reused if we don't do this.
                path = self.libdir+"/modules/search/"+candidateid
                moduleid = "search-"+candidateid
                try:
                    #Initialise module
                    module, moduleinfo, filewatch = self.newModule(path, moduleid, "search", False, None) #NOTE: never used in system mode
                    #Add module to modules
                    self.modules[moduleid] = module
                    #Add module's metadata to cache
                    self.moduleinfo[moduleid] = moduleinfo
                    #Initiate filewatches for this module
                    result = {}
                    for i in filewatch:
                        try:
                            result[i] = os.path.getmtime(i)
                        except Exception as e:
                            print(_("Failed to add %s to filewatch: %s") % (i, e))
                    self.modulefilewatch[moduleid] = result
                except Exception as e:
                    print(_("Failed to load search module %s: %s") % (candidateid, e))


    def finishInitGUI(self):
        #Signal the GUI to finish its loading process and go past its splash screen
        self.initialised = True
        # Tell the GUI to finish loading
        self.modules["gui"].finishInitGUI()

    def spawnGUI(self, command="", targetid="", moduleid="", sourceid="", subsourceid=""):
        #Reopen GUI if closed, and go to a page in the GUI if one is given
        self.modules["gui"].spawnGUI(command, targetid, moduleid, sourceid, subsourceid) #Don't wait this time as this time acts as a window open trigger

        #TODO: Allow stripping the 'itemmgmt-' from the sourceid, and adding it back in automatically here if not present?


    def dbusSessionSignals(self):
        #Receive DBus signals to perform certain actions, and respond to certain methods, in the session bus
        pass #TODO

    def dbusSystemSignals(self):
        #Receive DBus signals to perform certain actions in the system bus
        pass #TODO
        #FIXME: this should probably be moved into a separate class or something for the system mode


    ############################################
    # Settings
    ############################################
    def reloadConfigs(self):
        #Refreshes settings from file
        result = {}
        # Get defaults
        with open(self.usrdir + "/defaults.json", 'r') as fp:
            result = json.loads(fp.read())
        # Then append custom settings
        if os.path.isfile(self.configdir + "/configs.json"):
            with open(self.configdir + "/configs.json", 'r') as fp:
                result = self.dictMerge(result, json.loads(fp.read()))

        if result == {}:
            raise StoriumBrainException(_("Config files are empty"))

        #Pass settings to Storium
        self.configs = result

        #NOTE: Should be followed up by sending a signal to all userland instances to reload their settings if this is in system mode
        #NOTE: Should be followed up by a signal to GUI to reload those settings

    def setConfig(self, settingid, value):
        #Sets a setting via Superuser, then updates the setting's value here and sends signal to superuser to reloadSettings
        #TODO: Write custom values to /etc/feren-storium/config.json
        pass #TODO


    ############################################
    # Module Initialisation
    ############################################
    def newModule(self, modulepath, moduleid, moduletype, systemmode, extraapi=None):
        #Initialise module and its information
        ############################################
        # Metadata Checks/Initialisation
        ############################################
        if not os.path.isfile(modulepath + "/metadata.json"):
            raise StoriumBrainException(_("Module does not contain information"))
        with open(modulepath + "/metadata.json", 'r') as fp:
            moduleinfo = json.loads(fp.read())
        #Check that required values are present
        for i in self.moduleinforequirements["all"]:
            if i not in moduleinfo:
                raise StoriumBrainException(_("%s is missing from module information") % i)
        if moduleinfo["APIVersion"] != self.apiversion:
            raise StoriumBrainException(_("Module is not compatible"))
        if "conditionFilesExist" in moduleinfo:
            for i in moduleinfo["conditionFilesExist"]:
                if not os.path.isfile(i):
                    #Attempt to show the dependency's name in the correct language in the exception message
                    missingitem = self.getTranslation(moduleinfo["conditionFilesExist"][i])
                    if missingitem == None:
                        #If there is no name for the dependency, we show this double-error
                        raise StoriumBrainException(_("While trying to show a dependency error, an invalid module error occurred"))
                    else:
                        raise StoriumBrainException(_("%s is not installed, but is required by this module") % missingitem)
        #Check that required values, in the current API, are present
        for i in self.moduleinforequirements[moduletype]:
            if i not in moduleinfo:
                raise StoriumBrainException(_("%s is missing from module information") % i)
        if moduletype != "gui:configs": #Might as well skip all this when initialising Settings
            if "watchFiles" in moduleinfo:
                filewatch = moduleinfo["watchFiles"]
            else:
                filewatch = []
            #Clean up remaining module information
            moduleinfo.pop("conditionFilesExist", None)
            moduleinfo.pop("watchFiles", None)
            moduleinfo.pop("APIVersion")
            for i in ["fullname", "summary"] + self.moduleinfoextras[moduletype]:
                #Only keep the locale-appropriate translation in cache
                moduleinfo[i] = self.getTranslation(moduleinfo[i])
            count = 0
            while count < len(moduleinfo["authors"]):
                moduleinfo["authors"][count]["name"] = self.getTranslation(moduleinfo["authors"][count]["name"])
                count += 1

        #Check the module has code, and that said code is valid
        if not os.path.isfile(modulepath + "/module.py"):
            raise StoriumBrainException(_("Module does not contain code"))
        with open(modulepath + "/module.py", 'r') as modulecheck:
            check = False
            for i in modulecheck:
                if i.startswith("class module(") and moduletype != "gui:configs":
                    check = True
                elif i.startswith("class settings(") and moduletype == "gui:configs":
                    check = True
            if check == False:
                raise StoriumBrainException(_("Module does not contain required class"))

        self.GUIupdateInitStatus(_("Initialising %s...") % moduleinfo["fullname"])

        ############################################
        # Module Initialisation
        ############################################
        exceptionstr = ""
        try:
            #Create a module container and initialise the module inside the container
            i = ModuleContainer(modulepath)

            if moduletype != "gui:configs":
                if extraapi == None:
                    result = i.module.module(self.genericapi, systemmode)
                else:
                    result = i.module.module(self.genericapi, extraapi, systemmode)
            else:
                result = i.module.settings()

            #Inform the module of its ID so it can use it later
            result.moduleid = moduleid
        except Exception as e:
            raise StoriumBrainException(e)

        if moduletype != "gui:configs":
            return result, moduleinfo, filewatch
        else:
            return result

    def getTranslation(self, value, getid=False):
        for i in [locale.getlocale()[0], locale.getlocale()[0].split("_")[0], "C"]:
            if i in value:
                if getid == False:
                    return value[i]
                else:
                    return i
        return None
                    
                    
    ############################################
    # API Callbacks - Generic API
    ############################################
    def APIenterStagingMode(self):
        #Check we're in systemd mode before continuing
        if True: #TODO: Add systemd mode, and a check to ensure we're in it
            return
        #Enables tasks staging in systemd mode, and sends a signal to all userland Storium instances to also enter staging mode
        pass #TODO

    def APIgetItemInformation(self, itemid, moduleid, sourceid):
        #TODO: Recursive translate function
        #Returns information of the supplied item
        if moduleid not in self.modules:
            raise StoriumBrainException(_("%s is not a loaded module") % moduleid)

        #Return information from task if there is one
        task = self.getTaskID(itemid, moduleid, sourceid)
        if task != None:
            return copy.deepcopy(self.taskManager.tasksOrder[task]["info"])

        result = copy.deepcopy(self.modules[moduleid].getItemInformation(itemid, sourceid))
        #Use only strings appropriate to the current language
        return self.recurTranslate(result)

    def APIgetItemName(self, itemid, moduleid, sourceid):
        #Returns only the human-readable name of the supplied item
        result = copy.deepcopy(self.modules[moduleid].getItemName(itemid, sourceid))
        return self.getTranslation(result)


    #TODO: (was getExtraRequiredSourcesInstalled) Move to pending tasks runner, to check each time
        # uninstalled = []
        # pendinginstall = []
        # pendingremoval = []
        # for dep in deps: # Only keep note of disabled sources
        #     status = self.APIgetItemStatus(itemid, itemid.split("-itemsource-")[0], "itemsource")
        #     #NOTE: Sources can only have Installed and Not Installed states per each state in APIgetItemStatus
        #     if status == 0:
        #         uninstalled.append(dep)
        #     elif status == 1 or status == 7:
        #         pendinginstall.append(dep)
        #     elif status == 6 or status == 10:
        #         pendingremoval.append(dep)
        # return uninstalled, pendinginstall, pendingremoval
        #TODO: For items pendinginstall, wait until they are complete before showing this dependency confirmation dialog

    def APIgetIcon(self, itemid, moduleid, sourceid, iconurl):
        #Downloads the icon to cache and returns it
        #Also returns the icon in cache if it's already downloaded and not older than 4 days
        target = itemid+":"+moduleid+":"+sourceid
        cachelocat = self.getFromCache(target, "icons")
        if cachelocat != "":
            return cachelocat
        #Download the icon to the cache
        self.generateCache()
        r=requests.get(iconurl, headers=self.requestHeaders)
        with open(self.usercachedir + "/icons/" + target, "wb") as f:
            f.write(r.content)
        return self.usercachedir + "/icons/" + target

    def APIgetImages(self, folder, images):
        #Gets each image from the images dict, and puts them in the cache folder named the folder variable value
        pass #TODO


    def APIgetSourceInformation(self, moduleid, sourceid):
        #Return information from task if there is one
        task = self.getTaskID(sourceid, moduleid, "source")
        if task != None:
            return copy.deepcopy(self.taskManager.tasksOrder[task]["info"])

        #Source fallback information
        defaults = {"elevated": False, "defereasymode": False, \
            "sourceElevated": False, "priority": 50}

        #Returns information about a single source
        result = copy.deepcopy(self.modules[moduleid].getSourceInformation(sourceid))
        #Fill in missing optional values
        for i in defaults:
            if i not in result:
                result[i] = defaults[i]
        #Use only strings appropriate to the current language
        return self.recurTranslate(result)


    def APIisItemMappedBySource(self, itemid, moduleid, sourceid):
        #Returns True if itemid from sourceid of moduleid is mapped to by any sources, otherwise False.
        pass #TODO


    def APIgetSourceStatus(self, moduleid, sourceid):
        #getItemStatus, but for sources instead.
        # Not currently a task:
        #  0: Not installed
        #  1: Installed
        #  2: Installed (mandatory)
        # Queued:
        #  3: Pending installation
        #  4: Pending removal
        # In progress:
        #  5: Installing...
        #  6: Removing...

        #Check if the source is mapped to an item
        if moduleid + ":" + sourceid in self.sourceItemMaps:
            itemmap = self.sourceItemMaps[moduleid + ":" + sourceid]
            #Get item status of the item
            itemstatus = self.APIgetItemStatus(itemmap["itemid"], itemmap["moduleid"], itemmap["sourceid"])
            #Translate and return the appropriate value
            # NOTE: Update available -> Installed, Reinstalling -> Installing
            if itemstatus == 1 or itemstatus == 2:
                return 1
            elif itemstatus == 3 or itemstatus == 4:
                return 2
            elif itemstatus == 5 or itemstatus == 6 or itemstatus == 7 or itemstatus == 13:
                return 3
            elif itemstatus == 8:
                return 4
            elif itemstatus == 9 or itemstatus == 10 or itemstatus == 11:
                return 5
            elif itemstatus == 12:
                return 6
            else: #Uninstalled, missing source, or unknown = Uninstalled
                return 0

        #Check there's a task
        task = self.getTaskID(sourceid, moduleid, "source")
        if task != None:
            #Pending Tasks
            for tgroup in self.taskManager.myTasks["pending"]:
                for grouptype in ["sourcestasks", "tasks"]:
                    if task in tgroup[grouptype]:
                        if tgroup[grouptype][task]["operation"] == "install":
                            return 3
                        elif tgroup[grouptype][task]["operation"] == "remove":
                            return 4
            #Queued and/or Running Task(s)
            #TODO: Have a way to determine running superuser tasks, then implement here
            task = ":".join(task.split(":")[2:]) #Remove moduleid and superuser indicator
            for ttype in ["queue", "staged"]:
                #FIXME: Should source management be stagable?
                if task in self.taskManager.myTasks[ttype][moduleid]:
                    inprogress = True if ttype == "queue" and self.taskManager.myTasks[ttype][moduleid].index(taskid) == 0 else False
                    taskbody = self.taskManager.myTasks[ttype][moduleid][taskid]
                    if taskbody["operation"] == "install":
                        if inprogress == True:
                            return 5
                        else:
                            return 3
                    elif taskbody["operation"] == "remove":
                        if inprogress == True:
                            return 6
                        else:
                            return 4
        #No task? Query the module for the current status.
        return copy.deepcopy(self.modules[moduleid].getSourceStatus(sourceid))


    def dictMerge(self, target, writeover):
        for i in writeover.keys():
            if i in target: #Check if value exists and is a dictionary too
                if type(writeover[i]) is dict and type(target[i]) is dict:
                    #If so, recursively update the value
                    target[i] = self.dictMerge(target[i], writeover[i])
                    continue #Proceed to next key without running below code
            target[i] = writeover[i]
        return target

    def isInitialised(self):
        #Has Storium finished initialising?
        return self.initialised

    ############################################
    # Brain-only Callbacks - Generic
    ############################################
    def recurTranslate(self, target):
        if type(target) is dict:
            for i in target.keys(): #Recurse into each item of the dict
                target[i] = self.recurTranslate(target[i])
            if "C" in target: #Only dictionaries contain translations
                return self.getTranslation(target)
        elif type(target) is list:
            count = 0
            for i in target: #Recurse into each item of the list
                target[count] = self.recurTranslate(target[count])
                count += 1
        return target

    def checkLockFile(self, lockfilelocation):
        #Checks the PID in lockfilelocation exists - if so, returns True
        #Otherwise, and if lockfilelocation does not exist, return False
        pass #TODO

    def searchItemSort(self, results):
        #Sorts results given, before removing all characters up to their first ':' and returning the sorted version of results with these changes
        pass #TODO

    def generateCache(self):
        for i in [self.usercachedir, self.usercachedir + "/icons", self.usercachedir + "/images"]:
            if not os.path.isdir(i):
                os.mkdir(i)

    def getFromCache(self, filename, folder):
        #Check cache folder exists
        if not os.path.isdir(self.usercachedir):
            return ""
        self.deleteAgedCache(self.usercachedir + "/" + folder + "/" + filename)
        if os.path.isfile(self.usercachedir + "/" + folder + "/" + filename):
            return self.usercachedir + "/" + folder + "/" + filename
        else:
            return ""

    def deleteAgedCache(self, filepath):
        if os.path.isfile(filepath):
            #Check if the file is 4+ days old
            creationtime = int(datetime.date.strftime(datetime.datetime.fromtimestamp(os.path.getmtime(filepath)), "%Y%m%d"))
            currenttime = int(datetime.date.strftime(datetime.date.today(), "%Y%m%d"))
            if currenttime-creationtime >= 4: #If so delete it
                os.remove(filepath)
        #TODO: Delete all outdated cache on Storium launch.

    def getTaskID(self, itemid, moduleid, sourceid):
        #Checks if there is a task for itemid from sourceid in moduleid, and if so return the task ID in tasksOrder, otherwise return None
        for i in self.taskManager.tasksOrder:
            task = self.taskManager.tasksOrder[i]
            if task["itemid"] == itemid and task["moduleid"] == moduleid \
                and task["sourceid"] == sourceid:
                return i
        return None


    ############################################
    # API Callbacks - Tasks API
    ############################################
    def APIupdateTask(self, taskid, newstatus, newprogress):
        #Sends signal to GUI to update any representations of the task taskid, and the item it is managing, to reflect a change of status and/or progress in the task.
        pass #TODO

    def APIsetTaskCancellable(self, taskid, value):
        #Sets if the task can be cancelled, and sends signal to GUI to update task representations' cancel button to reflect this change
        pass #TODO

    def APIgetItemRequiredChanges(self, itemid, moduleid, sourceid):
        #Queries moduleid and returns required installations, updates, and removals as 3 individual lists of dictionaries containing an itemid and sourceid each.
        return [], [], [] #TODO

    def APIgetItemRequiredExtraSources(self, itemid, moduleid, sourceid):
        #Queries moduleid and returns any extra sources that are required as a list containing a sourceid each.
        return [] #TODO

    def APIgetItemBonuses(self, itemid, moduleid, sourceid, subsourceid):
        #Queries moduleid and returns the bonuses available to use on itemid from sourceid
        pass #TODO


    def APIshowItemErrorDialog(self, itemid, moduleid, sourceid, extras, errormsg):
        #Shows an error dialog, via the GUI, informing the user that the task has failed and why it failed.
        pass #TODO

    def APIrefreshTasksPage(self):
        #Tells the GUI to refresh the tasks page
        thread = Thread(target=self.modules["gui"].refreshTasksPage,
                        args=())
        thread.daemon = True
        thread.start()

    def APIrefreshItemPage(self, itemid, moduleid, sourceid):
        #Tells GUI to refresh any representations', of itemid from sourceid of moduleid
        pass #TODO


    def APIrefreshItemStatus(self, itemid, moduleid, sourceid):
        #Tells GUI to refresh the status of representations', of itemid from sourceid of moduleid
        thread = Thread(target=self.modules["gui"].refreshItemStatus,
                        args=(itemid, moduleid, sourceid))
        thread.daemon = True
        thread.start()

    def APIrefreshSourceStatus(self, moduleid, sourceid):
        #Same as refreshItemStatus, but actions on sources instead.
        pass #TODO


    def APIinvalidateItemInfoCache(self, moduleids=[], itemids=[]):
        #Tells modules in moduleids to delete their item information cache for items in itemids
        #Then, launches APIrefreshItemPage for each possible source
        pass #TODO

    def APIinvalidateItemStatusCache(self, moduleids=[], itemids=[]):
        #Tells modules in moduleids to delete their item status cache for items in itemids
        for i in moduleids:
            if i not in self.modules:
                raise StoriumBrainException(_("%s is not a loaded module") % i)
            self.modules[i].invalidateItemStatusCache(itemids)


    def APIinvalidateSourceInfoCache(self, moduleids=[], sourceids=[]): #FIXME: Needs Settings UI reaction design
        #Same as invalidateItemInfoCache, except actions on sources instead.
        pass #TODO

    def APIinvalidateSourceStatusCache(self, moduleids=[], sourceids=[]):
        #Same as invalidateItemStatusCache, except actions on sources instead.
        pass #TODO


    def APIreinitModulesIfFileWatch(self, finishedtaskid):
        #Reinitialises modules that have file watches on files that have changed after this task

        #To reinitialise modules, call queueReinitModule(moduleid) so that the module only reinitialises once its update tasks are completed
        pass #TODO

    ############################################
    # Brain-only Callbacks - Tasks
    ############################################
    def refreshTasksOrder(self):
        #Merges superuser tasks list with userland tasks list, in chronological order, and stores it as the tasksorder variable the GUI references
        pass #TODO

    def holdUntilTasksCompleted(self):
        #Enables tasks staging, and then holds code until all tasks in all modules are complete in userland, or superuser in systemd mode, are complete.
        pass #TODO

    def runShutdownUpdates(self):
        #Moves all tasks in 'waitingforshutdown' to queue, changes Plymouth mode to Updates, and runs the queue, while removing each task from updatetasks.json as they complete.
        pass #TODO

    def beginQueueCountdown(self):
        #Waits 1 hour before automatically starting the queued tasks.
        pass #TODO

    def queueReinitModule(self, moduleid):
        #Queues module for reinitialisation once unimportant tasks are the only queued tasks left for it
        pass #TODO

    def reinitModule(self, moduleid):
        #Reinitialises a module unless there are still update or related-to-update tasks queued in which case the function instantly returns
        #If reinitialisation fails, restartStorium() is triggered.
        pass #TODO


    ############################################
    # API Callbacks - GUI API
    ############################################
    def APIgetCustomCategories(self):
        #Returns the categories each item management module wants to place items into
        result = {}
        for i in self.modules:
            if i.startswith("itemmgmt-"):
                result[i] = copy.deepcopy(self.modules[i].getCustomCategories())
        return result

    def APIallItemsFilterCategory(self, category, maximum=200, randomise=False, allCategoriesStartingWith=False):
        #Lists all items in a category, until the maximum number of items are listed.
        #  randomise: Whether to get X randomly picked items from the items listed, where X is the value of maximum
        #    NOTE: If the number of items listed is less than maximum, randomisation is disabled
        #  allCategoriesStartingWith: Queries in all categories whose IDs start with the value of category (e.g.: 'applications-' will list applications-* categories)

        #TODO: support for other arguments, and alphabetical sorting by names
        result = []
        for i in self.modules:
            if i.startswith("itemmgmt-"):
                ii = copy.deepcopy(self.modules[i].getItemsFromCategory(category))
                for item in ii:
                    if item not in result:
                        result.append(item)
        #TODO: Convert result list's structure to the one used in search, through info of their default sources, and use search sorter

        return result


    def APIallItemsInstalledFromSource(self, moduleid, sourceid):
        #Returns all items installed from a specific source
        #TODO: Sanity checks
        return copy.deepcopy(self.modules[moduleid].allItemsInstalledFromSource(sourceid))


    def APIgetAvailableSources(self, itemid):
        #Returns all available sources, from all modules, for this itemid
        # Get non-sorted order of sources first, and segment by priority
        unsorted = {}
        for i in self.modules:
            if i.startswith("itemmgmt-"):
                sources = copy.deepcopy(self.modules[i].getAvailableSources(itemid))
                for source in sources:
                    #Append full source information to the source if currently empty
                    if sources[source] == {}:
                        sources[source] = self.APIgetSourceInformation(i, source)
                    else:
                        #If pre-supplied, make sure it's only showing localised values
                        sources[source] = self.recurTranslate(sources[source])
                    sourceid = i + "/" + source
                    priority = sources[source]["priority"]
                    #Reduce priority of redirection sources
                    if "redirectitemid" in sources[source]:
                        priority += 900
                    #Add to matching segment
                    if priority not in unsorted:
                        unsorted[priority] = {}
                    unsorted[priority][sourceid] = sources[source]
                    del unsorted[priority][sourceid]["priority"] #Redundant
        #If there's only 0-1 sources, return them immediately as sorting is redundant
        if len(unsorted) == 0:
            return unsorted
        elif len(unsorted) == 1:
            for i in unsorted:
                if len(unsorted[i]) <= 1:
                    return unsorted[i]
        #Sort priorities
        priorities = []
        for i in unsorted:
            priorities.append((i, unsorted[i]))
        del unsorted #No longer needed
        priorities.sort(key=self.sortFirst)
        #For each priority, sort their sources, and then merge the sources into one dict
        count = 0
        result = {}
        for priority in priorities:
            itemlist = []
            #Alphanumercalbetically sort the sources, per priority, based on their human-readable names
            for i in priority[1]:
                itemlist.append((priority[1][i]["fullname"], i))
            itemlist.sort(key=self.sortFirst)
            for i in itemlist: #Reassemble the sources, now in order, to a dict
                sourceid = i[1]
                result[sourceid] = priority[1][sourceid]
            count += 1
        del priorities
        #Return the ordered sources
        return result
    def sortFirst(self, i):
        return i[0]


    def APIgetSourceExists(self, moduleid, sourceid):
        #Returns True if the specified source exists in moduleid
        if self.modules[moduleid].getSourceExists(sourceid) == True:
            return True
        else:
            return False


    def APIgetItemStatus(self, itemid, moduleid, sourceid):
        #Returns the item's status as an ID out of the following, as well as the subsource if installed:
        # Not currently a task:
        #  0: Not installed
        #  1: Installed
        #  2: Out of date
        #  3: Installed (mandatory)
        #  4: Out of date (mandatory)
        # Queued:
        #  5: Pending installation
        #  6: Pending reinstallation
        #  7: Pending updating
        #  8: Pending removal
        # In progress:
        #  9: Installing...
        #  10: Reinstalling...
        #  11: Updating...
        #  12: Removing...
        # Waiting for shutdown:
        #  13: Waiting for shutdown
        # Missing source:
        #  21: Missing source

        #Check there's a task
        task = self.getTaskID(itemid, moduleid, sourceid)
        if task != None:
            #Pending Tasks
            for tgroup in self.taskManager.myTasks["pending"]:
                for grouptype in ["sourcestasks", "tasks"]:
                    if task in tgroup[grouptype]:
                        if tgroup[grouptype][task]["operation"] == "install":
                            return 5, ""
                            #No point supplying the subsource as it'll be checked for again post-task
                        elif tgroup[grouptype][task]["operation"] == "reinstall":
                            return 6, ""
                        elif tgroup[grouptype][task]["operation"] == "update":
                            return 7, ""
                        elif tgroup[grouptype][task]["operation"] == "remove":
                            return 8, ""
            #Queued and/or Running Task(s)
            #TODO: Have a way to determine running superuser tasks, then implement here
            task = ":".join(task.split(":")[2:]) #Remove moduleid and superuser indicator
            for ttype in ["queue", "staged"]:
                if task in self.taskManager.myTasks[ttype][moduleid]:
                    inprogress = True if ttype == "queue" and self.taskManager.myTasks[ttype][moduleid].index(taskid) == 0 else False
                    taskbody = self.taskManager.myTasks[ttype][moduleid][taskid]
                    if taskbody["operation"] == "install":
                        if inprogress == True:
                            return 9, ""
                        else:
                            return 5, ""
                    elif taskbody["operation"] == "reinstall":
                        if inprogress == True:
                            return 10, ""
                        else:
                            return 6, ""
                    elif taskbody["operation"] == "update":
                        if inprogress == True:
                            return 11, ""
                        else:
                            return 7, ""
                    elif taskbody["operation"] == "remove":
                        if inprogress == True:
                            return 12, ""
                        else:
                            return 8, ""
            #Task is waiting for shutdown
            #FIXME: waitingforshutdown should be exclusive to Superuser, and as such checked for such
            if task in self.taskManager.myTasks["waitingforshutdown"][moduleid]:
                return 13, ""
        #No task? Query the module for the current status.
        status, subsource = copy.deepcopy(self.modules[moduleid].getItemStatus(itemid, sourceid))
        if status == 0:
            #Check source is installed
            sourcestatus = self.APIgetSourceStatus(moduleid, sourceid)
            if sourcestatus == 0 or sourcestatus == 4 or sourcestatus == 6:
                return 21, ""
        return status, subsource


    def APIgetExtraItemButtons(self, itemid, moduleid, sourceid, status):
        #Returns extra buttons for displaying in the item details page, and installation notifications
        # Formatted as [{"text": "Test button", "tooltip": "An example button", "icon": "softwarecenter", callback: callbackHere}]

        orig = self.modules[moduleid].getExtraItemButtons(itemid, sourceid, status)
        result = []
        limit = 0
        for i in orig:
            if limit >= 2:
                break #Don't allow more than 2 buttons for sanity reasons
            a = {}
            a["text"] = copy.deepcopy(i["text"])
            a["tooltip"] = copy.deepcopy(i["tooltip"])
            a["icon"] = copy.deepcopy(i["icon"])
            a["callback"] = i["callback"]
            result.append(a)
            limit += 1
        return result


    def APIinstallItem(self, itemid, moduleid, sourceid, subsourceid, tasksintent, sourcesintent):
        #Adds the item to pending tasks to be confirmed, before starting the tasks runner if it is not currently running
        #Also runs invalidateItemStatus cache on this specific itemid.
        self.taskManager.newTask(itemid, moduleid, "install", sourceid, subsourceid, tasksintent, sourcesintent, "", [])

    def APIreinstallItem(self, itemid, moduleid, sourceid, subsourceid, tasksintent, sourcesintent):
        #APIinstallitem, but reinstallation instead.
        self.taskManager.newTask(itemid, moduleid, "reinstall", sourceid, subsourceid, tasksintent, sourcesintent, "", [])

    def APIupdateItem(self, itemid, moduleid, sourceid, subsourceid, tasksintent, sourcesintent):
        self.taskManager.newTask(itemid, moduleid, "update", sourceid, subsourceid, tasksintent, sourcesintent, "", [])

    def APIremoveItem(self, itemid, moduleid, sourceid, subsourceid, tasksintent, sourcesintent):
        self.taskManager.newTask(itemid, moduleid, "remove", sourceid, subsourceid, tasksintent, sourcesintent, "", [])


    def APIgetAvailableBonuses(self, itemid, moduleid, sourceid, subsourceid):
        #Returns list of available bonus IDs
        pass #TODO


    def APIchangeItemBonuses(self, itemid, moduleid, sourceid, subsourceid, bonuses):
        #Ran upon user confirming changes to bonuses - initiates a new queued task with the 'changebonuses' operation, before starting the tasks runner if it is not currently running
        #Tasks for each bonus change, with becauseof values set to the resulting task as well as having matching operations, will be added
        pass #TODO


    def APIinstallSource(self, moduleid, sourceid, sourcesintent):
        #Adds the source to pending tasks to be confirmed, before starting the tasks runner if it is not currently running
        #Also runs invalidateSourceStatus on this specific sourceid.
        self.taskManager.newTask(sourceid, moduleid, "install", "source", "", sourcesintent, "", "", [])

    def APIremoveSource(self, moduleid, sourceid, sourcesintent):
        #installSource, but removal instead.
        self.taskManager.newTask(sourceid, moduleid, "remove", "source", "", sourcesintent, "", "", [])


    def APIgetTasks(self):
        #Returns the current merged tasks order
        return copy.deepcopy(self.taskManager.tasksOrder)

    def APIcheckForUpdates(self):
        #Gets the values of getProblemItems from all item management modules, then getUpdates, getDrivers, and getInstalled. Then, assembles them and runs reloadInstalledPage in the GUI with the IDs in those aforementioned segmented-lists, while making sure each ID only appears once.
        pass #TODO

    #TODO: put this in GUI
    #reloadInstalledPage(problemItems, updates, drivers, installed):
    #    #Reloads all the parts of the drivers/problems/updates/drivers/installed page, except for Tasks, using the lists provided in the function's arguments.

    ############################################
    # Brain-only Callbacks - GUI
    ############################################
    def getPreferSystemWideInstalls(self):
        #Returns the value of the preference according to the GUI module
        pass #TODO

    def confirmPendingItem(self, taskgroupid):
        #Shows a confirmation dialog, and returns True if the user chose to continue, else False
        pass #TODO

    def refreshSources(self, itemid):
        #Calls refreshSources in the GUI with this itemid.
        pass #TODO

    def taskProgress(self, taskid):
        #Displays the progress and status of a task in a Terminal-friendly format
        #Used in single instance mode, or when running this executable with a management argument
        pass #TODO

    def restartStore(self):
        #Runs holdUntilTasksCompleted in the Tasks API, saves staged tasks, deletes its lockfile, spawns a new Store process and then exits.
        #In systemd mode, restarts the service before exiting.
        pass #TODO

    def GUIupdateInitStatus(self, value):
        #Updates initialisation status on the GUI's splash screen, if there is one, else prints to command line
        if "gui" in self.modules:
            self.modules["gui"].updateInitStatus(value)
        if self.guiconfigs != None and self.guiconfigs.getDebugOutput() == True:
            print(_("Initialisation process: %s") % value)


    ############################################
    # API Callbacks - ItemMgmt API
    ############################################
    def APIshowGUIToast(self, moduleid, text, icon="info"):
        pass #TODO

    def APIpkgMgrWaiting(self, moduleid, value, taskid):
        pass #TODO

    def APIgetPreferSysInst(self, moduleid):
        pass #TODO

    def APIrefreshLibraryPage(self, moduleid):
        pass #TODO


    def APImapSourceToItem(self, moduleid, sourceid, targetsourceid, itemid, targetmoduleid=None):
        #Maps the source specified to the specified item, so long as the targetmoduleid accepts the request
        if targetmoduleid == None:
            #If set to None, targetmoduleid == moduleid
            targetmoduleid = moduleid
        else:
            #Ask the targetmoduleid if we can go ahead with this
            if self.modules[targetmoduleid].isOperationPermitted(moduleid, sourceid, "mapSourceToItem", targetmoduleid, itemid, targetsourceid) != True:
                raise StoriumBrainException(_("%s rejected the source mapping request.") % targetmoduleid)
        #Add the map to mapping storage
        self.sourceItemMaps[moduleid + ":" + sourceid] = {"itemid": itemid, "sourceid": targetsourceid, "moduleid": targetmoduleid}


    def APIunmapSourceToItem(self, moduleid, sourceid):
        #Removes the mapping of sourceid to itemid from currently mapped sources
        if moduleid + ":" + sourceid in self.sourceItemMaps:
            self.sourceItemMaps.pop(moduleid + ":" + sourceid)



############################################
# Initialise Storium API
############################################
if __name__ == "__main__":
    app = StoriumBrain()
    app.run()
